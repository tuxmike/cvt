/*
   The MIT License (MIT)

   Copyright (c) 2011 - 2013, Philipp Heise and Sebastian Klose

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   THE SOFTWARE.
*/

#define __STDC_LIMIT_MACROS 1

#include <cvt/util/SIMD.h>
#include <cvt/math/Math.h>
#include <cvt/util/SIMDSSE.h>
#include <cvt/util/SIMDSSE2.h>
#include <cvt/util/SIMDSSE3.h>
#include <cvt/util/SIMDSSSE3.h>
#include <cvt/util/SIMDSSE41.h>
#include <cvt/util/SIMDSSE42.h>
#include <cvt/util/SIMDAVX.h>
#include <cvt/util/CPU.h>


namespace cvt {
    const float _table_alpha_u8_f[256] = {
        0.000000000000f, 0.003921568627f, 0.007843137255f, 0.011764705882f,
        0.015686274510f, 0.019607843137f, 0.023529411765f, 0.027450980392f,
        0.031372549020f, 0.035294117647f, 0.039215686275f, 0.043137254902f,
        0.047058823529f, 0.050980392157f, 0.054901960784f, 0.058823529412f,
        0.062745098039f, 0.066666666667f, 0.070588235294f, 0.074509803922f,
        0.078431372549f, 0.082352941176f, 0.086274509804f, 0.090196078431f,
        0.094117647059f, 0.098039215686f, 0.101960784314f, 0.105882352941f,
        0.109803921569f, 0.113725490196f, 0.117647058824f, 0.121568627451f,
        0.125490196078f, 0.129411764706f, 0.133333333333f, 0.137254901961f,
        0.141176470588f, 0.145098039216f, 0.149019607843f, 0.152941176471f,
        0.156862745098f, 0.160784313725f, 0.164705882353f, 0.168627450980f,
        0.172549019608f, 0.176470588235f, 0.180392156863f, 0.184313725490f,
        0.188235294118f, 0.192156862745f, 0.196078431373f, 0.200000000000f,
        0.203921568627f, 0.207843137255f, 0.211764705882f, 0.215686274510f,
        0.219607843137f, 0.223529411765f, 0.227450980392f, 0.231372549020f,
        0.235294117647f, 0.239215686275f, 0.243137254902f, 0.247058823529f,
        0.250980392157f, 0.254901960784f, 0.258823529412f, 0.262745098039f,
        0.266666666667f, 0.270588235294f, 0.274509803922f, 0.278431372549f,
        0.282352941176f, 0.286274509804f, 0.290196078431f, 0.294117647059f,
        0.298039215686f, 0.301960784314f, 0.305882352941f, 0.309803921569f,
        0.313725490196f, 0.317647058824f, 0.321568627451f, 0.325490196078f,
        0.329411764706f, 0.333333333333f, 0.337254901961f, 0.341176470588f,
        0.345098039216f, 0.349019607843f, 0.352941176471f, 0.356862745098f,
        0.360784313725f, 0.364705882353f, 0.368627450980f, 0.372549019608f,
        0.376470588235f, 0.380392156863f, 0.384313725490f, 0.388235294118f,
        0.392156862745f, 0.396078431373f, 0.400000000000f, 0.403921568627f,
        0.407843137255f, 0.411764705882f, 0.415686274510f, 0.419607843137f,
        0.423529411765f, 0.427450980392f, 0.431372549020f, 0.435294117647f,
        0.439215686275f, 0.443137254902f, 0.447058823529f, 0.450980392157f,
        0.454901960784f, 0.458823529412f, 0.462745098039f, 0.466666666667f,
        0.470588235294f, 0.474509803922f, 0.478431372549f, 0.482352941176f,
        0.486274509804f, 0.490196078431f, 0.494117647059f, 0.498039215686f,
        0.501960784314f, 0.505882352941f, 0.509803921569f, 0.513725490196f,
        0.517647058824f, 0.521568627451f, 0.525490196078f, 0.529411764706f,
        0.533333333333f, 0.537254901961f, 0.541176470588f, 0.545098039216f,
        0.549019607843f, 0.552941176471f, 0.556862745098f, 0.560784313725f,
        0.564705882353f, 0.568627450980f, 0.572549019608f, 0.576470588235f,
        0.580392156863f, 0.584313725490f, 0.588235294118f, 0.592156862745f,
        0.596078431373f, 0.600000000000f, 0.603921568627f, 0.607843137255f,
        0.611764705882f, 0.615686274510f, 0.619607843137f, 0.623529411765f,
        0.627450980392f, 0.631372549020f, 0.635294117647f, 0.639215686275f,
        0.643137254902f, 0.647058823529f, 0.650980392157f, 0.654901960784f,
        0.658823529412f, 0.662745098039f, 0.666666666667f, 0.670588235294f,
        0.674509803922f, 0.678431372549f, 0.682352941176f, 0.686274509804f,
        0.690196078431f, 0.694117647059f, 0.698039215686f, 0.701960784314f,
        0.705882352941f, 0.709803921569f, 0.713725490196f, 0.717647058824f,
        0.721568627451f, 0.725490196078f, 0.729411764706f, 0.733333333333f,
        0.737254901961f, 0.741176470588f, 0.745098039216f, 0.749019607843f,
        0.752941176471f, 0.756862745098f, 0.760784313725f, 0.764705882353f,
        0.768627450980f, 0.772549019608f, 0.776470588235f, 0.780392156863f,
        0.784313725490f, 0.788235294118f, 0.792156862745f, 0.796078431373f,
        0.800000000000f, 0.803921568627f, 0.807843137255f, 0.811764705882f,
        0.815686274510f, 0.819607843137f, 0.823529411765f, 0.827450980392f,
        0.831372549020f, 0.835294117647f, 0.839215686275f, 0.843137254902f,
        0.847058823529f, 0.850980392157f, 0.854901960784f, 0.858823529412f,
        0.862745098039f, 0.866666666667f, 0.870588235294f, 0.874509803922f,
        0.878431372549f, 0.882352941176f, 0.886274509804f, 0.890196078431f,
        0.894117647059f, 0.898039215686f, 0.901960784314f, 0.905882352941f,
        0.909803921569f, 0.913725490196f, 0.917647058824f, 0.921568627451f,
        0.925490196078f, 0.929411764706f, 0.933333333333f, 0.937254901961f,
        0.941176470588f, 0.945098039216f, 0.949019607843f, 0.952941176471f,
        0.956862745098f, 0.960784313725f, 0.964705882353f, 0.968627450980f,
        0.972549019608f, 0.976470588235f, 0.980392156863f, 0.984313725490f,
        0.988235294118f, 0.992156862745f, 0.996078431373f, 1.000000000000f
    };


    static const float _table_srgb_u8_f[256] = {
        0.000000000000f, 0.000303526984f, 0.000607053967f, 0.000910580951f,
        0.001214107934f, 0.001517634918f, 0.001821161901f, 0.002124688885f,
        0.002428215868f, 0.002731742852f, 0.003035269835f, 0.003346535764f,
        0.003676507324f, 0.004024717018f, 0.004391442037f, 0.004776953481f,
        0.005181516702f, 0.005605391624f, 0.006048833023f, 0.006512090793f,
        0.006995410187f, 0.007499032043f, 0.008023192985f, 0.008568125618f,
        0.009134058702f, 0.009721217320f, 0.010329823030f, 0.010960094006f,
        0.011612245180f, 0.012286488357f, 0.012983032342f, 0.013702083047f,
        0.014443843596f, 0.015208514423f, 0.015996293366f, 0.016807375753f,
        0.017641954488f, 0.018500220128f, 0.019382360957f, 0.020288563057f,
        0.021219010376f, 0.022173884793f, 0.023153366178f, 0.024157632449f,
        0.025186859627f, 0.026241221895f, 0.027320891639f, 0.028426039504f,
        0.029556834438f, 0.030713443733f, 0.031896033073f, 0.033104766571f,
        0.034339806809f, 0.035601314875f, 0.036889450401f, 0.038204371595f,
        0.039546235277f, 0.040915196907f, 0.042311410621f, 0.043735029257f,
        0.045186204386f, 0.046665086337f, 0.048171824227f, 0.049706565984f,
        0.051269458374f, 0.052860647023f, 0.054480276442f, 0.056128490050f,
        0.057805430191f, 0.059511238163f, 0.061246054232f, 0.063010017653f,
        0.064803266693f, 0.066625938644f, 0.068478169844f, 0.070360095697f,
        0.072271850682f, 0.074213568380f, 0.076185381481f, 0.078187421805f,
        0.080219820314f, 0.082282707130f, 0.084376211544f, 0.086500462037f,
        0.088655586286f, 0.090841711183f, 0.093058962847f, 0.095307466631f,
        0.097587347142f, 0.099898728247f, 0.102241733088f, 0.104616484091f,
        0.107023102978f, 0.109461710778f, 0.111932427837f, 0.114435373827f,
        0.116970667759f, 0.119538427988f, 0.122138772230f, 0.124771817561f,
        0.127437680436f, 0.130136476690f, 0.132868321554f, 0.135633329655f,
        0.138431615032f, 0.141263291140f, 0.144128470858f, 0.147027266498f,
        0.149959789811f, 0.152926151996f, 0.155926463708f, 0.158960835061f,
        0.162029375639f, 0.165132194502f, 0.168269400190f, 0.171441100733f,
        0.174647403656f, 0.177888415984f, 0.181164244250f, 0.184474994500f,
        0.187820772301f, 0.191201682741f, 0.194617830442f, 0.198069319560f,
        0.201556253794f, 0.205078736390f, 0.208636870145f, 0.212230757414f,
        0.215860500114f, 0.219526199729f, 0.223227957317f, 0.226965873510f,
        0.230740048524f, 0.234550582161f, 0.238397573812f, 0.242281122466f,
        0.246201326708f, 0.250158284730f, 0.254152094331f, 0.258182852922f,
        0.262250657530f, 0.266355604803f, 0.270497791013f, 0.274677312060f,
        0.278894263477f, 0.283148740430f, 0.287440837727f, 0.291770649818f,
        0.296138270798f, 0.300543794416f, 0.304987314070f, 0.309468922818f,
        0.313988713376f, 0.318546778125f, 0.323143209113f, 0.327778098057f,
        0.332451536346f, 0.337163615048f, 0.341914424909f, 0.346704056355f,
        0.351532599500f, 0.356400144146f, 0.361306779784f, 0.366252595599f,
        0.371237680474f, 0.376262122991f, 0.381326011433f, 0.386429433787f,
        0.391572477750f, 0.396755230726f, 0.401977779832f, 0.407240211902f,
        0.412542613484f, 0.417885070848f, 0.423267669986f, 0.428690496614f,
        0.434153636175f, 0.439657173841f, 0.445201194516f, 0.450785782838f,
        0.456411023180f, 0.462076999654f, 0.467783796112f, 0.473531496148f,
        0.479320183101f, 0.485149940056f, 0.491020849848f, 0.496932995061f,
        0.502886458033f, 0.508881320855f, 0.514917665377f, 0.520995573204f,
        0.527115125706f, 0.533276404011f, 0.539479489012f, 0.545724461370f,
        0.552011401512f, 0.558340389634f, 0.564711505705f, 0.571124829465f,
        0.577580440430f, 0.584078417891f, 0.590618840919f, 0.597201788364f,
        0.603827338855f, 0.610495570808f, 0.617206562420f, 0.623960391675f,
        0.630757136346f, 0.637596873994f, 0.644479681971f, 0.651405637420f,
        0.658374817279f, 0.665387298282f, 0.672443156958f, 0.679542469633f,
        0.686685312435f, 0.693871761292f, 0.701101891933f, 0.708375779892f,
        0.715693500506f, 0.723055128922f, 0.730460740090f, 0.737910408773f,
        0.745404209540f, 0.752942216776f, 0.760524504675f, 0.768151147248f,
        0.775822218317f, 0.783537791526f, 0.791297940333f, 0.799102738014f,
        0.806952257669f, 0.814846572216f, 0.822785754396f, 0.830769876775f,
        0.838799011741f, 0.846873231510f, 0.854992608124f, 0.863157213454f,
        0.871367119199f, 0.879622396888f, 0.887923117882f, 0.896269353374f,
        0.904661174391f, 0.913098651793f, 0.921581856277f, 0.930110858375f,
        0.938685728458f, 0.947306536733f, 0.955973353249f, 0.964686247894f,
        0.973445290398f, 0.982250550333f, 0.991102097114f, 1.000000000000f
    };

    static const uint8_t _table_f_srgb_ub[8193] = {
        0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06,
        0x06, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C,
        0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11,
        0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
        0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x18, 0x18, 0x18, 0x18, 0x18, 0x19, 0x19,
        0x19, 0x19, 0x19, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1C, 0x1C, 0x1C,
        0x1C, 0x1C, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1F, 0x1F,
        0x1F, 0x1F, 0x1F, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x24, 0x24,
        0x24, 0x24, 0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26, 0x26,
        0x26, 0x26, 0x26, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
        0x28, 0x28, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
        0x2A, 0x2A, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2B, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
        0x2C, 0x2C, 0x2C, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2E, 0x2E, 0x2E, 0x2E,
        0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x30, 0x30,
        0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x35,
        0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
        0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x38,
        0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
        0x39, 0x39, 0x39, 0x39, 0x39, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A, 0x3A,
        0x3A, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B, 0x3C, 0x3C, 0x3C,
        0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
        0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E,
        0x3E, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x40, 0x40,
        0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41, 0x41, 0x41, 0x41, 0x41,
        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43,
        0x43, 0x43, 0x43, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
        0x44, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x46,
        0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x47, 0x47, 0x47,
        0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x48, 0x48, 0x48, 0x48,
        0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x49, 0x49, 0x49, 0x49, 0x49,
        0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A,
        0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4A, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B,
        0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C,
        0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D,
        0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E,
        0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F,
        0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50,
        0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51,
        0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x52, 0x52,
        0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x52, 0x53, 0x53, 0x53, 0x53,
        0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x54, 0x54,
        0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56,
        0x56, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
        0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58,
        0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x58, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59,
        0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x5A, 0x5A, 0x5A, 0x5A,
        0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A,
        0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B, 0x5B,
        0x5B, 0x5B, 0x5B, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
        0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D,
        0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5D, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E,
        0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E,
        0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F,
        0x5F, 0x5F, 0x5F, 0x5F, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
        0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
        0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x62, 0x62,
        0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
        0x62, 0x62, 0x62, 0x62, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
        0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
        0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x65,
        0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
        0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
        0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67, 0x67,
        0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
        0x67, 0x67, 0x67, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
        0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69,
        0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69,
        0x69, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A,
        0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B,
        0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B,
        0x6B, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C,
        0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D,
        0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D,
        0x6D, 0x6D, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E,
        0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6E, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F,
        0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F, 0x6F,
        0x6F, 0x6F, 0x6F, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70,
        0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x71, 0x71, 0x71,
        0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71,
        0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72,
        0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72,
        0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73,
        0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74,
        0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74,
        0x74, 0x74, 0x74, 0x74, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75,
        0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x76,
        0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76,
        0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x76, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
        0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
        0x77, 0x77, 0x77, 0x77, 0x77, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
        0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78, 0x78,
        0x78, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79,
        0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x7A, 0x7A, 0x7A,
        0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A,
        0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7A, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B,
        0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7B,
        0x7B, 0x7B, 0x7B, 0x7B, 0x7B, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C,
        0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C,
        0x7C, 0x7C, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D,
        0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7D, 0x7E,
        0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,
        0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7F, 0x7F, 0x7F, 0x7F,
        0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
        0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
        0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82,
        0x82, 0x82, 0x82, 0x82, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
        0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
        0x83, 0x83, 0x83, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
        0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,
        0x84, 0x84, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
        0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85,
        0x85, 0x85, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
        0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86,
        0x86, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
        0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87,
        0x87, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
        0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
        0x88, 0x88, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
        0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89,
        0x89, 0x89, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A,
        0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A, 0x8A,
        0x8A, 0x8A, 0x8A, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B,
        0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B, 0x8B,
        0x8B, 0x8B, 0x8B, 0x8B, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C,
        0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C,
        0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D,
        0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D,
        0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8D, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E,
        0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E,
        0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F,
        0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F,
        0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x8F, 0x90, 0x90, 0x90, 0x90,
        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
        0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x91,
        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
        0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91,
        0x91, 0x91, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
        0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
        0x92, 0x92, 0x92, 0x92, 0x92, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93,
        0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94,
        0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x95, 0x95, 0x95, 0x95,
        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
        0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95,
        0x95, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
        0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
        0x96, 0x96, 0x96, 0x96, 0x96, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
        0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98,
        0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x99,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A,
        0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A,
        0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B,
        0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B,
        0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B,
        0x9B, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C,
        0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C,
        0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D,
        0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D,
        0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9E, 0x9E,
        0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E,
        0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E,
        0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F,
        0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F,
        0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0xA0, 0xA0, 0xA0, 0xA0,
        0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
        0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
        0xA0, 0xA0, 0xA0, 0xA0, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1,
        0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1,
        0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA2, 0xA2, 0xA2, 0xA2,
        0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2,
        0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA2,
        0xA2, 0xA2, 0xA2, 0xA2, 0xA2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA4, 0xA4, 0xA4,
        0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4,
        0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4,
        0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5,
        0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5,
        0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5,
        0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6,
        0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6,
        0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7,
        0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7,
        0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7, 0xA7,
        0xA7, 0xA7, 0xA7, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8,
        0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8,
        0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA9, 0xA9, 0xA9,
        0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9,
        0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9,
        0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xA9, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
        0xAA, 0xAA, 0xAA, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB,
        0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB,
        0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAB, 0xAC, 0xAC,
        0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC,
        0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC,
        0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAC, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD,
        0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD,
        0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD,
        0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE,
        0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE,
        0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE, 0xAE,
        0xAE, 0xAE, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF,
        0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF,
        0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xAF, 0xB0,
        0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0,
        0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0,
        0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB1, 0xB1, 0xB1, 0xB1,
        0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1,
        0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1,
        0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB1, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2,
        0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2,
        0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2,
        0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3,
        0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3,
        0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3, 0xB3,
        0xB3, 0xB3, 0xB3, 0xB3, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,
        0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,
        0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,
        0xB4, 0xB4, 0xB4, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5,
        0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5,
        0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5,
        0xB5, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6,
        0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6,
        0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6, 0xB6,
        0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7,
        0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7,
        0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB7, 0xB8,
        0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8,
        0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8,
        0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xB9,
        0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9,
        0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9,
        0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xB9, 0xBA,
        0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA,
        0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA,
        0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBB,
        0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
        0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
        0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
        0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC,
        0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC,
        0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC,
        0xBC, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD,
        0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD,
        0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD,
        0xBD, 0xBD, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE,
        0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE,
        0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE, 0xBE,
        0xBE, 0xBE, 0xBE, 0xBE, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF,
        0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF,
        0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF,
        0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
        0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
        0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
        0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1,
        0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1,
        0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1,
        0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
        0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
        0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2,
        0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC2, 0xC3, 0xC3, 0xC3,
        0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
        0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
        0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
        0xC3, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4,
        0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4,
        0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4,
        0xC4, 0xC4, 0xC4, 0xC4, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5,
        0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5,
        0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5,
        0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC5, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
        0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
        0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
        0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC7, 0xC7, 0xC7,
        0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7,
        0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7,
        0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xC7,
        0xC7, 0xC7, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8,
        0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8,
        0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8,
        0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9,
        0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9,
        0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9,
        0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xC9, 0xCA, 0xCA, 0xCA, 0xCA,
        0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA,
        0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA,
        0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA,
        0xCA, 0xCA, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB,
        0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB,
        0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB,
        0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCB, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCD, 0xCD,
        0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
        0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
        0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
        0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE,
        0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE,
        0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE,
        0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCE, 0xCF, 0xCF, 0xCF, 0xCF,
        0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
        0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
        0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
        0xCF, 0xCF, 0xCF, 0xCF, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0,
        0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0,
        0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0,
        0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xD1, 0xD1, 0xD1, 0xD1,
        0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1,
        0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1,
        0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1,
        0xD1, 0xD1, 0xD1, 0xD1, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2,
        0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2,
        0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2,
        0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD3, 0xD3, 0xD3, 0xD3,
        0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3,
        0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3,
        0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3,
        0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4,
        0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4,
        0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4,
        0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xD5,
        0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
        0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
        0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
        0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6,
        0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6,
        0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6,
        0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6,
        0xD6, 0xD6, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7,
        0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7,
        0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7,
        0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD7, 0xD8, 0xD8, 0xD8,
        0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8,
        0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8,
        0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8,
        0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9,
        0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9,
        0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9,
        0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9,
        0xD9, 0xD9, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA,
        0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA,
        0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA,
        0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDB, 0xDB,
        0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB,
        0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB,
        0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB,
        0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
        0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
        0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
        0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
        0xDD, 0xDD, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE,
        0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE,
        0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE,
        0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDE, 0xDF,
        0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF,
        0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF,
        0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF,
        0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xE0, 0xE0, 0xE0, 0xE0,
        0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
        0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
        0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
        0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1,
        0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1,
        0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1,
        0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1,
        0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2,
        0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2,
        0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2,
        0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2,
        0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE2, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3,
        0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3,
        0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3,
        0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3,
        0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
        0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
        0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
        0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4, 0xE4,
        0xE4, 0xE4, 0xE4, 0xE4, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
        0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
        0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
        0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5, 0xE5,
        0xE5, 0xE5, 0xE5, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6,
        0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6,
        0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6,
        0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6,
        0xE6, 0xE6, 0xE6, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7,
        0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7,
        0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7,
        0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7,
        0xE7, 0xE7, 0xE7, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8,
        0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8,
        0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8,
        0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8,
        0xE8, 0xE8, 0xE8, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9,
        0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9,
        0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9,
        0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9,
        0xE9, 0xE9, 0xE9, 0xE9, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEA,
        0xEA, 0xEA, 0xEA, 0xEA, 0xEA, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
        0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
        0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
        0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB,
        0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEB, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC,
        0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC,
        0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC,
        0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC,
        0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED,
        0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED,
        0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED,
        0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED,
        0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xED, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
        0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
        0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
        0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
        0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEF, 0xEF,
        0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF,
        0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF,
        0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF,
        0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF,
        0xEF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
        0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
        0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
        0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
        0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1,
        0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1,
        0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1,
        0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1,
        0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF1, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
        0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
        0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
        0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
        0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF3, 0xF3, 0xF3,
        0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3,
        0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3,
        0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3,
        0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3,
        0xF3, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4,
        0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4,
        0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4,
        0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4,
        0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF4, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5,
        0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5,
        0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5,
        0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5,
        0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF5, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6,
        0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6,
        0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6,
        0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6,
        0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6, 0xF6,
        0xF6, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
        0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
        0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
        0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
        0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8,
        0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8,
        0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8,
        0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8,
        0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF9, 0xF9, 0xF9,
        0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9,
        0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9,
        0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9,
        0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9,
        0xF9, 0xF9, 0xF9, 0xF9, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA,
        0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA,
        0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA,
        0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA,
        0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
        0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
        0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
        0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
        0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB,
        0xFB, 0xFB, 0xFB, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
        0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
        0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
        0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
        0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD,
        0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD,
        0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD,
        0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD,
        0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD,
        0xFD, 0xFD, 0xFD, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
        0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
        0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
        0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
        0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF
    };

#define SRGB_U8_TO_F( x ) ( _table_srgb_u8_f[ x ] )
#define U8_TO_F( x )	  ( _table_alpha_u8_f[ x ] )

    static inline uint8_t F_TO_SRGB_U8( float val )
    {
        ssize_t idx  = ( ssize_t ) ( val * ( float ) ( 1 << 13 ) );
        if( idx < 0 ) return 0x0;
        if( idx >= ( 1 << 13 ) ) return 0xff;
        return _table_f_srgb_ub[ idx ];
    }

    static inline uint32_t _mix4U8( uint32_t src1, uint32_t src2, uint32_t alpha )
    {
        uint32_t __tmp, __tmp2;
        __tmp = ( ( src2 >> 8) & 0xff00ff ) - ( ( src1 >> 8 ) & 0xff00ff );
        __tmp *= alpha;
//		__tmp += 0x800080;
        __tmp += src1 & 0xff00ff00;
        __tmp &= 0xff00ff00;
        __tmp2 = ( src2 & 0xff00ff ) - ( src1 & 0xff00ff );
        __tmp2 *= alpha;
//		__tmp2 += 0x800080;
        __tmp2 = __tmp2  >> 8;
        __tmp2 += src1 & 0xff00ff;
        __tmp2 &= 0xff00ff;
        return __tmp + __tmp2;
    }


	static inline uint8_t _addsU8( uint8_t a, uint8_t b )
	{
		uint16_t c = a + b;
		return ( c | ( 0x100 - ( c >> 8 ) ) ) & 0xff;
	}

	static inline uint8_t _subsU8( uint8_t a, uint8_t b )
	{
		uint16_t c = a - b;
		return ( c & ~( 0x100 - ( c >> 15 ) ) ) & 0xff;
	}

    static inline int32_t _floor( float v )
    {
        Math::_flint32 fl;
        int32_t ret = ( int32_t ) v;
        fl.f = v;
        ret -= fl.i >> 31;
        return ret;
    }

    SIMD* SIMD::_simd = 0;

    SIMD* SIMD::get( SIMDType type )
    {
        if( type == SIMD_BEST ) {
            CPUFeatures cpuf;
            cpuf = cpuFeatures();
            if( cpuf & CPU_AVX ){
                return new SIMDAVX();
            } else if( cpuf & CPU_SSE4_2 ){
                return new SIMDSSE42();
            } else if( cpuf & CPU_SSE4_1 ) {
                return new SIMDSSE41();
            } else if( cpuf & CPU_SSSE3 ) {
                return new SIMDSSSE3();
            } else if( cpuf & CPU_SSE3 ) {
                return new SIMDSSE3();
            }else if( cpuf & CPU_SSE2 ) {
                return new SIMDSSE2();
            }else if( cpuf & CPU_SSE ) {
                return new SIMDSSE();
            } else {
                return new SIMD();
            }
        } else {
            switch( type ) {
                default:
                case SIMD_BASE: return new SIMD();
                case SIMD_SSE: return new SIMDSSE();
                case SIMD_SSE2: return new SIMDSSE2();
                case SIMD_SSE3: return new SIMDSSE3();
                case SIMD_SSSE3: return new SIMDSSSE3();
                case SIMD_SSE41: return new SIMDSSE41();
                case SIMD_SSE42: return new SIMDSSE42();
                case SIMD_AVX: return new SIMDAVX();
            }
        }
    }

    SIMDType SIMD::bestSupportedType()
    {
        CPUFeatures cpuf;
        cpuf = cpuFeatures();
        if( cpuf & CPU_AVX ){
            return SIMD_AVX;
        } else if( cpuf & CPU_SSE4_2 ){
            return SIMD_SSE42;
        } else if( cpuf & CPU_SSE4_1 ) {
            return SIMD_SSE41;
        } else if( cpuf & CPU_SSSE3 ) {
            return SIMD_SSSE3;
        } else if( cpuf & CPU_SSE3 ) {
            return SIMD_SSE3;
        } else if( cpuf & CPU_SSE2 ) {
            return SIMD_SSE2;
        } else if( cpuf & CPU_SSE ) {
            return SIMD_SSE;
        } else {
            return SIMD_BASE;
        }
    }

    void SIMD::force( SIMDType type )
    {
        if( _simd )
            delete _simd;
        _simd = get( type );
    }

    SIMD* SIMD::instance()
    {
        if( !_simd )
            _simd = get( SIMD_BEST );
        return _simd;
    }

    void SIMD::SetValueU8( uint8_t* dst, const uint8_t value, const size_t n ) const
    {
        size_t i = n & 0x3;
        uint32_t v = ( value << 24 ) | ( value << 16 ) | ( value << 8 ) | value;

        SetValueU32( ( uint32_t* ) dst, v, n >> 2 );
        dst += n & ( ~ 0x03 );
        while( i-- )
            *dst++ = value;
    }

    void SIMD::SetValueU16( uint16_t* dst, const uint16_t value, const size_t n ) const
    {
        uint32_t v = ( value << 16 ) | value;

        SetValueU32( ( uint32_t* ) dst, v, n >> 1 );
        if( n & 1 ) {
            dst += n & ( ~ 0x01 );
            *dst++ = value;
        }
    }

    void SIMD::SetValueU32( uint32_t* dst, const uint32_t value, const size_t n ) const
    {
        size_t i = n;
        while( i-- )
            *dst++ = value;
    }

    void SIMD::SetValue1f( float* dst, const float value, const size_t n ) const
    {
        size_t i = n;
        while( i-- )
            *dst++ = value;
    }

    void SIMD::SetValue2f( float* dst, const float (&value)[ 2 ], const size_t n ) const
    {
        float v[ 4 ] = { value[ 0 ], value[ 1 ], value[ 0 ], value[ 1 ] };

        SetValue4f( dst, v, n >> 1 );
        if( n & 0x01 ) {
            dst += ( n & ( ~0x01 ) ) * 2;
            *dst++ = value[ 0 ];
            *dst++ = value[ 1 ];
        }
    }

    void SIMD::SetValue4f( float* dst, const float (&value)[ 4 ], const size_t n ) const
    {
        size_t i = n;
        while( i-- ) {
            *dst++ = value[ 0 ];
            *dst++ = value[ 1 ];
            *dst++ = value[ 2 ];
            *dst++ = value[ 3 ];
        }
    }

    void SIMD::Add( float* dst, float const* src1, float const* src2, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src1++ + *src2++;
            *dst++ = *src1++ + *src2++;
            *dst++ = *src1++ + *src2++;
            *dst++ = *src1++ + *src2++;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src1++ + *src2++;
    }

    void SIMD::Sub( float* dst, float const* src1, float const* src2, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src1++ - *src2++;
            *dst++ = *src1++ - *src2++;
            *dst++ = *src1++ - *src2++;
            *dst++ = *src1++ - *src2++;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src1++ - *src2++;
    }

    void SIMD::Mul( float* dst, float const* src1, float const* src2, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src1++ * *src2++;
            *dst++ = *src1++ * *src2++;
            *dst++ = *src1++ * *src2++;
            *dst++ = *src1++ * *src2++;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src1++ * *src2++;
    }

    void SIMD::Div( float* dst, float const* src1, float const* src2, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src1++ / *src2++;
            *dst++ = *src1++ / *src2++;
            *dst++ = *src1++ / *src2++;
            *dst++ = *src1++ / *src2++;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src1++ / *src2++;
    }

    void SIMD::AddValue1f( float* dst, float const* src, const float value, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ + value;
            *dst++ = *src++ + value;
            *dst++ = *src++ + value;
            *dst++ = *src++ + value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ + value;
    }

    void SIMD::SubValue1f( float* dst, float const* src, const float value, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ - value;
            *dst++ = *src++ - value;
            *dst++ = *src++ - value;
            *dst++ = *src++ - value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ - value;
    }

    void SIMD::MulValue1f( float* dst, float const* src, const float value, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ * value;
    }

    void SIMD::DivValue1f( float* dst, float const* src, const float value, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ / value;
            *dst++ = *src++ / value;
            *dst++ = *src++ / value;
            *dst++ = *src++ / value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ / value;
    }

    void SIMD::MulValue1ui16( uint16_t* dst, uint16_t const* src, float value, size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ * value;
    }

    void SIMD::AddValue4f( float* dst, float const* src1, const float (&value)[ 4 ], const size_t n ) const
    {
        size_t i = n >> 2;
        size_t x = 0;
        while( i-- ) {
            *dst++ = *src1++ + value[ 0 ];
            *dst++ = *src1++ + value[ 1 ];
            *dst++ = *src1++ + value[ 2 ];
            *dst++ = *src1++ + value[ 3 ];
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ = *src1++ + value[ x++ ];
            x &= 0x03;
        }
    }

    void SIMD::SubValue4f( float* dst, float const* src1, const float (&value)[ 4 ], const size_t n ) const
    {
        size_t i = n >> 2;
        size_t x = 0;
        while( i-- ) {
            *dst++ = *src1++ - value[ 0 ];
            *dst++ = *src1++ - value[ 1 ];
            *dst++ = *src1++ - value[ 2 ];
            *dst++ = *src1++ - value[ 3 ];
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ = *src1++ - value[ x++ ];
            x &= 0x03;
        }
    }


    void SIMD::MulValue4f( float* dst, float const* src1, const float (&value)[ 4 ], const size_t n ) const
    {
        size_t i = n >> 2;
        size_t x = 0;
        while( i-- ) {
            *dst++ = *src1++ * value[ 0 ];
            *dst++ = *src1++ * value[ 1 ];
            *dst++ = *src1++ * value[ 2 ];
            *dst++ = *src1++ * value[ 3 ];
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ = *src1++ * value[ x++ ];
            x &= 0x03;
        }
    }


    void SIMD::DivValue4f( float* dst, float const* src1, const float (&value)[ 4 ], const size_t n ) const
    {
        size_t i = n >> 2;
        size_t x = 0;
        while( i-- ) {
            *dst++ = *src1++ / value[ 0 ];
            *dst++ = *src1++ / value[ 1 ];
            *dst++ = *src1++ / value[ 2 ];
            *dst++ = *src1++ / value[ 3 ];
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ = *src1++ / value[ x++ ];
            x &= 0x03;
        }
    }

    void SIMD::MulValue1fx( Fixed * dst, const Fixed * src, Fixed value, size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ * value;
    }

    void SIMD::MulAddValue1fx( Fixed* dst, const Fixed* src, Fixed value, size_t n ) const
    {
        size_t i = n >> 2;

        if( value.native() == 0 )
            return;

        while( i-- ) {
            *dst++ += *src++ * value;
            *dst++ += *src++ * value;
            *dst++ += *src++ * value;
            *dst++ += *src++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ += *src++ * value;
    }

    void SIMD::MulU8Value1fx( Fixed * dst, const uint8_t* src, Fixed value, size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ * value;
    }

    void SIMD::MulAddU8Value1fx( Fixed* dst, const uint8_t* src, Fixed value, size_t n ) const
    {
        size_t i = n >> 2;

        if( value.native() == 0 )
            return;

        while( i-- ) {
            *dst++ += *src++ * value;
            *dst++ += *src++ * value;
            *dst++ += *src++ * value;
            *dst++ += *src++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ += *src++ * value;
    }


    void SIMD::MulU8Value1f( float* dst, const uint8_t* src, float value, size_t n ) const
	{
		size_t i = n >> 2;
        while( i-- ) {
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
            *dst++ = *src++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = *src++ * value;
	}

    void SIMD::BSwap16( uint16_t* dst, const uint16_t* src, size_t size ) const
    {
        uint16_t tmp;

        while( size-- ) {
            tmp = *src++;
            *dst++ = ( ( tmp << 8) & 0xff00 ) | ( ( tmp >> 8 ) & 0x00ff );
        }
    }

    void SIMD::BSwap32( uint32_t* dst, const uint32_t* src, size_t size ) const
    {
        uint32_t tmp;

        while( size-- ) {
            tmp = *src++;
            *dst++ =  ( ( tmp << 24 ) & 0xff000000 ) |
                      ( ( tmp <<  8 ) & 0x00ff0000 ) |
                      ( ( tmp >>  8 ) & 0x0000ff00 ) |
                      ( ( tmp >> 24 ) & 0x000000ff );
        }
    }

    void SIMD::BSwap64( uint64_t* dst, const uint64_t* src, size_t size ) const
    {
        uint64_t tmp;

        while( size-- ) {
            tmp = *src++;
            *dst++ = ( ( tmp << 56 ) & 0xff00000000000000UL ) |
                     ( ( tmp << 40 ) & 0x00ff000000000000UL ) |
                     ( ( tmp << 24 ) & 0x0000ff0000000000UL ) |
                     ( ( tmp <<  8 ) & 0x000000ff00000000UL ) |
                     ( ( tmp >>  8 ) & 0x00000000ff000000UL ) |
                     ( ( tmp >> 24 ) & 0x0000000000ff0000UL ) |
                     ( ( tmp >> 40 ) & 0x000000000000ff00UL ) |
                     ( ( tmp >> 56 ) & 0x00000000000000ffUL );
        }
    }


    float SIMD::SSD( const float* src1, const float* src2, const size_t n ) const
    {
        size_t i = n >> 2;

        float ssd = 0.0f;
        while( i-- ) {
            ssd += Math::sqr( *src1++ - *src2++ );
            ssd += Math::sqr( *src1++ - *src2++ );
            ssd += Math::sqr( *src1++ - *src2++ );
            ssd += Math::sqr( *src1++ - *src2++ );
        }

        i = n & 0x03;
        while( i-- ) {
            ssd += Math::sqr( *src1++ - *src2++ );
        }

        return ssd;
    }

    float SIMD::SSD( uint8_t const* src1, uint8_t const* src2, const size_t n ) const
    {
        size_t i = n >> 2;

        float ssd = 0.0f;
        while( i-- ) {
            ssd += Math::sqr( *src1++ - *src2++ );
            ssd += Math::sqr( *src1++ - *src2++ );
            ssd += Math::sqr( *src1++ - *src2++ );
            ssd += Math::sqr( *src1++ - *src2++ );
        }

        i = n & 0x03;
        while( i-- ) {
            ssd += Math::sqr( *src1++ - *src2++ );
        }

        return ssd;
    }

    float SIMD::sumSqr( float const* src, const size_t n ) const
    {
        size_t i = n >> 2;

        float sum = 0.0f;
        while( i-- ) {
            sum += Math::sqr( *src++ );
            sum += Math::sqr( *src++ );
            sum += Math::sqr( *src++ );
            sum += Math::sqr( *src++ );
        }

        i = n & 0x03;
        while( i-- ) {
            sum += Math::sqr( *src++ );
        }

        return sum;
    }

    float SIMD::SAD( const float* src1, const float* src2, const size_t n ) const
    {
        size_t i = n >> 2;

        float sad = 0.0f;
        while( i-- ) {
            sad += Math::abs( *src1++ - *src2++ );
            sad += Math::abs( *src1++ - *src2++ );
            sad += Math::abs( *src1++ - *src2++ );
            sad += Math::abs( *src1++ - *src2++ );
        }

        i = n & 0x03;
        while( i-- ) {
            sad += Math::abs( *src1++ - *src2++ );
        }

        return sad;
    }

    size_t SIMD::SAD( uint8_t const* src1, uint8_t const* src2, const size_t n ) const
    {
        size_t i = n >> 2;

        float sad = 0.0f;
        while( i-- ) {
            sad += Math::abs( ( int16_t )*src1++ - ( int16_t )*src2++ );
            sad += Math::abs( ( int16_t )*src1++ - ( int16_t )*src2++ );
            sad += Math::abs( ( int16_t )*src1++ - ( int16_t )*src2++ );
            sad += Math::abs( ( int16_t )*src1++ - ( int16_t )*src2++ );
        }

        i = n & 0x03;
        while( i-- ) {
            sad += Math::abs( ( int16_t )*src1++ - ( int16_t )*src2++ );
        }

        return sad;
    }

    float SIMD::NCC( const float* src1, const float* src2, const size_t n ) const
    {
        float mean1 = 0.0f;
        float mean2 = 0.0f;
        float mean12 = 0.0f;
        float meanSqr1 = 0.0f;
        float meanSqr2 = 0.0f;
        
        size_t i = n;
        while( i-- ) {
            float v1 = *src1++;
            float v2 = *src2++;
            
            mean1 += v1;
            mean2 += v2;
            mean12 += v1 * v2;
            meanSqr1 += Math::sqr( v1 );
            meanSqr2 += Math::sqr( v2 );
        }
        
        float nInv = 1.0f / (float) n;
        mean1 *= nInv;
        mean2 *= nInv;
        mean12 *= nInv;
        meanSqr1 *= nInv;
        meanSqr2 *= nInv;
        
        float cov = mean12 - ( mean1 * mean2 );
        float var1var2 = ( meanSqr1 - Math::sqr( mean1 ) ) * ( meanSqr2 - Math::sqr( mean2 ) );
        
        // Avoid division by zero
        if( var1var2 == 0.0f ) {
            var1var2 = Math::floatNext( 0.0f );
        }

        return Math::invSqrt( var1var2 ) * cov;
    }

    void SIMD::MulAddValue1f( float* dst, float const* src1, const float value, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ += *src1++ * value;
            *dst++ += *src1++ * value;
            *dst++ += *src1++ * value;
            *dst++ += *src1++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ += *src1++ * value;
    }

    void SIMD::MulSubValue1f( float* dst, float const* src1, const float value, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ -= *src1++ * value;
            *dst++ -= *src1++ * value;
            *dst++ -= *src1++ * value;
            *dst++ -= *src1++ * value;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ -= *src1++ * value;
    }

    void SIMD::MulAddValue4f( float* dst, float const* src1, const float (&value)[ 4 ], const size_t n ) const
    {
        size_t i = n >> 2;
        size_t x = 0;
        while( i-- ) {
            *dst++ += *src1++ * value[ 0 ];
            *dst++ += *src1++ * value[ 1 ];
            *dst++ += *src1++ * value[ 2 ];
            *dst++ += *src1++ * value[ 3 ];
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ += *src1++ * value[ x++ ];
            x &= 0x03;
        }
    }

    void SIMD::MulSubValue4f( float* dst, float const* src1, const float (&value)[ 4 ], const size_t n ) const
    {
        size_t i = n >> 2;
        size_t x = 0;
        while( i-- ) {
            *dst++ -= *src1++ * value[ 0 ];
            *dst++ -= *src1++ * value[ 1 ];
            *dst++ -= *src1++ * value[ 2 ];
            *dst++ -= *src1++ * value[ 3 ];
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ -= *src1++ * value[ x++ ];
            x &= 0x03;
        }
    }

	void SIMD::MinValueU8( uint8_t* dst, const uint8_t* src1, const uint8_t* src2, size_t n ) const
	{
		while( n-- ) {
			*dst++ = *src1 < *src2 ? *src1 : *src2;
			src1++;
			src2++;
		}
	}

	void SIMD::MinValueU16( uint16_t* dst, const uint16_t* src1, const uint16_t* src2, size_t n ) const
	{
		while( n-- ) {
			*dst++ = *src1 < *src2 ? *src1 : *src2;
			src1++;
			src2++;
		}
	}

	void SIMD::MinValue1f( float* dst, const float* src1, const float* src2, size_t n ) const
	{
		while( n-- ) {
			*dst++ = *src1 < *src2 ? *src1 : *src2;
			src1++;
			src2++;
		}
	}

	void SIMD::MaxValueU8( uint8_t* dst, const uint8_t* src1, const uint8_t* src2, size_t n ) const
	{
		while( n-- ) {
			*dst++ = *src1 > *src2 ? *src1 : *src2;
			src1++;
			src2++;
		}
	}

	void SIMD::MaxValueU16( uint16_t* dst, const uint16_t* src1, const uint16_t* src2, size_t n ) const
	{
		while( n-- ) {
			*dst++ = *src1 > *src2 ? *src1 : *src2;
			src1++;
			src2++;
		}
	}

	void SIMD::MaxValue1f( float* dst, const float* src1, const float* src2, size_t n ) const
	{
		while( n-- ) {
			*dst++ = *src1 > *src2 ? *src1 : *src2;
			src1++;
			src2++;
		}
	}

	void SIMD::MinValueVertU8( uint8_t* dst, const uint8_t** bufs, size_t numbufs, size_t n ) const
	{
		size_t i;

		for( i = 0; i <= n - 4; i += 4  ) {
			uint8_t min0, min1, min2, min3;
			const uint8_t* sptr = bufs[ 0 ] + i;
			min0 = sptr[ 0 ];
			min1 = sptr[ 1 ];
			min2 = sptr[ 2 ];
			min3 = sptr[ 3 ];

			for( size_t k = 1; k < numbufs; k++ ) {
				sptr = bufs[ k ] + i;
				min0 = min0 < sptr[ 0 ] ? min0 : sptr[ 0 ];
				min1 = min1 < sptr[ 1 ] ? min1 : sptr[ 1 ];
				min2 = min2 < sptr[ 2 ] ? min2 : sptr[ 2 ];
				min3 = min3 < sptr[ 3 ] ? min3 : sptr[ 3 ];
			}

			*dst++ = min0;
			*dst++ = min1;
			*dst++ = min2;
			*dst++ = min3;
		}

		for( ; i < n; i++ ) {
			uint8_t min = *( bufs[ 0 ] + i );
			for( size_t k = 1; k < numbufs; k++ ) {
				min = min < *( bufs[ k ] + i ) ? min : *( bufs[ k ] + i );
			}
			*dst++ = min;
		}
	}

	void SIMD::MinValueVertU16( uint16_t* dst, const uint16_t** bufs, size_t numbufs, size_t n ) const
	{
		size_t i;

		for( i = 0; i <= n - 4; i += 4  ) {
			uint16_t min0, min1, min2, min3;
			const uint16_t* sptr = bufs[ 0 ] + i;
			min0 = sptr[ 0 ];
			min1 = sptr[ 1 ];
			min2 = sptr[ 2 ];
			min3 = sptr[ 3 ];

			for( size_t k = 1; k < numbufs; k++ ) {
				sptr = bufs[ k ] + i;
				min0 = min0 < sptr[ 0 ] ? min0 : sptr[ 0 ];
				min1 = min1 < sptr[ 1 ] ? min1 : sptr[ 1 ];
				min2 = min2 < sptr[ 2 ] ? min2 : sptr[ 2 ];
				min3 = min3 < sptr[ 3 ] ? min3 : sptr[ 3 ];
			}

			*dst++ = min0;
			*dst++ = min1;
			*dst++ = min2;
			*dst++ = min3;
		}

		for( ; i < n; i++ ) {
			uint16_t min = *( bufs[ 0 ] + i );
			for( size_t k = 1; k < numbufs; k++ ) {
				min = min < *( bufs[ k ] + i ) ? min : *( bufs[ k ] + i );
			}
			*dst++ = min;
		}
	}

	void SIMD::MinValueVert1f( float* dst, const float** bufs, size_t numbufs, size_t n ) const
	{
		size_t i;

		for( i = 0; i <= n - 4; i += 4  ) {
			float min0, min1, min2, min3;
			const float* sptr = bufs[ 0 ] + i;
			min0 = sptr[ 0 ];
			min1 = sptr[ 1 ];
			min2 = sptr[ 2 ];
			min3 = sptr[ 3 ];

			for( size_t k = 1; k < numbufs; k++ ) {
				sptr = bufs[ k ] + i;
				min0 = min0 < sptr[ 0 ] ? min0 : sptr[ 0 ];
				min1 = min1 < sptr[ 1 ] ? min1 : sptr[ 1 ];
				min2 = min2 < sptr[ 2 ] ? min2 : sptr[ 2 ];
				min3 = min3 < sptr[ 3 ] ? min3 : sptr[ 3 ];
			}

			*dst++ = min0;
			*dst++ = min1;
			*dst++ = min2;
			*dst++ = min3;
		}

		for( ; i < n; i++ ) {
			float min = *( bufs[ 0 ] + i );
			for( size_t k = 1; k < numbufs; k++ ) {
				min = min < *( bufs[ k ] + i ) ? min : *( bufs[ k ] + i );
			}
			*dst++ = min;
		}
	}

	void SIMD::MaxValueVertU8( uint8_t* dst, const uint8_t** bufs, size_t numbufs, size_t n ) const
	{
		size_t i;

		for( i = 0; i <= n - 4; i += 4  ) {
			uint8_t max0, max1, max2, max3;
			const uint8_t* sptr = bufs[ 0 ] + i;
			max0 = sptr[ 0 ];
			max1 = sptr[ 1 ];
			max2 = sptr[ 2 ];
			max3 = sptr[ 3 ];

			for( size_t k = 1; k < numbufs; k++ ) {
				sptr = bufs[ k ] + i;
				max0 = max0 > sptr[ 0 ] ? max0 : sptr[ 0 ];
				max1 = max1 > sptr[ 1 ] ? max1 : sptr[ 1 ];
				max2 = max2 > sptr[ 2 ] ? max2 : sptr[ 2 ];
				max3 = max3 > sptr[ 3 ] ? max3 : sptr[ 3 ];
			}

			*dst++ = max0;
			*dst++ = max1;
			*dst++ = max2;
			*dst++ = max3;
		}

		for( ; i < n; i++ ) {
			uint8_t max = *( bufs[ 0 ] + i );
			for( size_t k = 1; k < numbufs; k++ ) {
				max = max > *( bufs[ k ] + i ) ? max : *( bufs[ k ] + i );
			}
			*dst++ = max;
		}
	}

	void SIMD::MaxValueVertU16( uint16_t* dst, const uint16_t** bufs, size_t numbufs, size_t n ) const
	{
		size_t i;

		for( i = 0; i <= n - 4; i += 4  ) {
			uint16_t max0, max1, max2, max3;
			const uint16_t* sptr = bufs[ 0 ] + i;
			max0 = sptr[ 0 ];
			max1 = sptr[ 1 ];
			max2 = sptr[ 2 ];
			max3 = sptr[ 3 ];

			for( size_t k = 1; k < numbufs; k++ ) {
				sptr = bufs[ k ] + i;
				max0 = max0 > sptr[ 0 ] ? max0 : sptr[ 0 ];
				max1 = max1 > sptr[ 1 ] ? max1 : sptr[ 1 ];
				max2 = max2 > sptr[ 2 ] ? max2 : sptr[ 2 ];
				max3 = max3 > sptr[ 3 ] ? max3 : sptr[ 3 ];
			}

			*dst++ = max0;
			*dst++ = max1;
			*dst++ = max2;
			*dst++ = max3;
		}

		for( ; i < n; i++ ) {
			uint16_t max = *( bufs[ 0 ] + i );
			for( size_t k = 1; k < numbufs; k++ ) {
				max = max > *( bufs[ k ] + i ) ? max : *( bufs[ k ] + i );
			}
			*dst++ = max;
		}
	}

	void SIMD::MaxValueVert1f( float* dst, const float** bufs, size_t numbufs, size_t n ) const
	{
		size_t i;

		for( i = 0; i <= n - 4; i += 4  ) {
			float max0, max1, max2, max3;
			const float* sptr = bufs[ 0 ] + i;
			max0 = sptr[ 0 ];
			max1 = sptr[ 1 ];
			max2 = sptr[ 2 ];
			max3 = sptr[ 3 ];

			for( size_t k = 1; k < numbufs; k++ ) {
				sptr = bufs[ k ] + i;
				max0 = max0 > sptr[ 0 ] ? max0 : sptr[ 0 ];
				max1 = max1 > sptr[ 1 ] ? max1 : sptr[ 1 ];
				max2 = max2 > sptr[ 2 ] ? max2 : sptr[ 2 ];
				max3 = max3 > sptr[ 3 ] ? max3 : sptr[ 3 ];
			}

			*dst++ = max0;
			*dst++ = max1;
			*dst++ = max2;
			*dst++ = max3;
		}

		for( ; i < n; i++ ) {
			float max = *( bufs[ 0 ] + i );
			for( size_t k = 1; k < numbufs; k++ ) {
				max = max > *( bufs[ k ] + i ) ? max : *( bufs[ k ] + i );
			}
			*dst++ = max;
		}
	}



	void SIMD::erodeSpanU8( uint8_t* dst, const uint8_t* src, size_t n, size_t radius ) const
	{
		size_t i = 0;
		const size_t b2 = n - radius - 2;
		const size_t step = radius * 2 + 1;
		uint8_t min;

		if( radius == 0 ) {
			memcpy( dst, src, n * sizeof( uint8_t ) );
			return;
		}

		/* border 1 */
		/* find min in 0 to radius */
		min = *src;
		for( size_t s = 1; s <= radius; s++ )
			min = min < *( src + s )? min:*(src + s );
		*dst++ = min;

		/* update min by including src + radius + i and update dst */
		for( i = 1; i < radius; i++ ) {
			min = min < *( src + radius + i ) ? min : *( src + radius + i );
			*dst++ = min;
		}

		/* main part */
		for(; i <= b2; i += 2 ) {
			min = *( src + 1 );
			for( size_t s = 2; s < step; s++ ) {
				min = min < *( src + s ) ? min : *( src + s );
			}
			*dst++ = min < *src ? min : *src;
			*dst++ = min < *( src + step ) ? min : *( src + step );
			src += 2;
		}

		for( ; i < n - radius; i++ ) {
			min = *src;
			for( size_t s = 1; s < step; s++ ) {
				min = min < *( src + s ) ? min : *( src + s );
			}
			*dst++ = min < *src ? min : *src;
			src++;
		}

		/* border 2 */
		size_t nend = n - i;
		for( i = 0; i < nend; i++ ) {
			min = *src;
			for( size_t s = 1; s < step - i - 1; s++ )
				min = min < *( src + s )? min:*(src + s );
			*dst++ = min;
			src++;
		}
	}

	void SIMD::erodeSpanU16( uint16_t* dst, const uint16_t* src, size_t n, size_t radius ) const
	{
		size_t i = 0;
		const size_t b2 = n - radius - 2;
		const size_t step = radius * 2 + 1;
		uint16_t min;

		if( radius == 0 ) {
			memcpy( dst, src, n * sizeof( uint16_t ) );
			return;
		}

		/* border 1 */
		/* find min in 0 to radius */
		min = *src;
		for( size_t s = 1; s <= radius; s++ )
			min = min < *( src + s )? min:*(src + s );
		*dst++ = min;

		/* update min by including src + radius + i and update dst */
		for( i = 1; i < radius; i++ ) {
			min = min < *( src + radius + i ) ? min : *( src + radius + i );
			*dst++ = min;
		}

		/* main part */
		for(; i <= b2; i += 2 ) {
			min = *( src + 1 );
			for( size_t s = 2; s < step; s++ ) {
				min = min < *( src + s ) ? min : *( src + s );
			}
			*dst++ = min < *src ? min : *src;
			*dst++ = min < *( src + step ) ? min : *( src + step );
			src += 2;
		}

		for( ; i < n - radius; i++ ) {
			min = *src;
			for( size_t s = 1; s < step; s++ ) {
				min = min < *( src + s ) ? min : *( src + s );
			}
			*dst++ = min < *src ? min : *src;
			src++;
		}

		/* border 2 */
		size_t nend = n - i;
		for( i = 0; i < nend; i++ ) {
			min = *src;
			for( size_t s = 1; s < step - i - 1; s++ )
				min = min < *( src + s )? min:*(src + s );
			*dst++ = min;
			src++;
		}
	}

	void SIMD::erodeSpan1f( float* dst, const float* src, size_t n, size_t radius ) const
	{
		size_t i = 0;
		const size_t b2 = n - radius - 2;
		const size_t step = radius * 2 + 1;
		float min;

		if( radius == 0 ) {
			memcpy( dst, src, n * sizeof( float ) );
			return;
		}

		/* border 1 */
		/* find min in 0 to radius */
		min = *src;
		for( size_t s = 1; s <= radius; s++ )
			min = min < *( src + s )? min:*(src + s );
		*dst++ = min;

		/* update min by including src + radius + i and update dst */
		for( i = 1; i < radius; i++ ) {
			min = min < *( src + radius + i ) ? min : *( src + radius + i );
			*dst++ = min;
		}

		/* main part */
		for(; i <= b2; i += 2 ) {
			min = *( src + 1 );
			for( size_t s = 2; s < step; s++ ) {
				min = min < *( src + s ) ? min : *( src + s );
			}
			*dst++ = min < *src ? min : *src;
			*dst++ = min < *( src + step ) ? min : *( src + step );
			src += 2;
		}

		for( ; i < n - radius; i++ ) {
			min = *src;
			for( size_t s = 1; s < step; s++ ) {
				min = min < *( src + s ) ? min : *( src + s );
			}
			*dst++ = min < *src ? min : *src;
			src++;
		}

		/* border 2 */
		size_t nend = n - i;
		for( i = 0; i < nend; i++ ) {
			min = *src;
			for( size_t s = 1; s < step - i - 1; s++ )
				min = min < *( src + s )? min:*(src + s );
			*dst++ = min;
			src++;
		}
	}

	void SIMD::dilateSpanU8( uint8_t* dst, const uint8_t* src, size_t n, size_t radius ) const
	{
		size_t i = 0;
		const size_t b2 = n - radius - 2;
		const size_t step = radius * 2 + 1;
		uint8_t max;

		if( radius == 0 ) {
			memcpy( dst, src, n * sizeof( uint8_t ) );
			return;
		}

		/* border 1 */
		/* find max in 0 to radius */
		max = *src;
		for( size_t s = 1; s <= radius; s++ )
			max = max > *( src + s )? max:*(src + s );
		*dst++ = max;

		/* update max by including src + radius + i and update dst */
		for( i = 1; i < radius; i++ ) {
			max = max > *( src + radius + i ) ? max : *( src + radius + i );
			*dst++ = max;
		}

		/* main part */
		for(; i <= b2; i += 2 ) {
			max = *( src + 1 );
			for( size_t s = 2; s < step; s++ ) {
				max = max > *( src + s ) ? max : *( src + s );
			}
			*dst++ = max > *src ? max : *src;
			*dst++ = max > *( src + step ) ? max : *( src + step );
			src += 2;
		}

		for( ; i < n - radius; i++ ) {
			max = *src;
			for( size_t s = 1; s < step; s++ ) {
				max = max > *( src + s ) ? max : *( src + s );
			}
			*dst++ = max > *src ? max : *src;
			src++;
		}

		/* border 2 */
		size_t nend = n - i;
		for( i = 0; i < nend; i++ ) {
			max = *src;
			for( size_t s = 1; s < step - i - 1; s++ )
				max = max > *( src + s )? max:*(src + s );
			*dst++ = max;
			src++;
		}
	}

	void SIMD::dilateSpanU16( uint16_t* dst, const uint16_t* src, size_t n, size_t radius ) const
	{
		size_t i = 0;
		const size_t b2 = n - radius - 2;
		const size_t step = radius * 2 + 1;
		uint16_t max;

		if( radius == 0 ) {
			memcpy( dst, src, n * sizeof( uint16_t ) );
			return;
		}

		/* border 1 */
		/* find max in 0 to radius */
		max = *src;
		for( size_t s = 1; s <= radius; s++ )
			max = max > *( src + s )? max:*(src + s );
		*dst++ = max;

		/* update max by including src + radius + i and update dst */
		for( i = 1; i < radius; i++ ) {
			max = max > *( src + radius + i ) ? max : *( src + radius + i );
			*dst++ = max;
		}

		/* main part */
		for(; i <= b2; i += 2 ) {
			max = *( src + 1 );
			for( size_t s = 2; s < step; s++ ) {
				max = max > *( src + s ) ? max : *( src + s );
			}
			*dst++ = max > *src ? max : *src;
			*dst++ = max > *( src + step ) ? max : *( src + step );
			src += 2;
		}

		for( ; i < n - radius; i++ ) {
			max = *src;
			for( size_t s = 1; s < step; s++ ) {
				max = max > *( src + s ) ? max : *( src + s );
			}
			*dst++ = max > *src ? max : *src;
			src++;
		}

		/* border 2 */
		size_t nend = n - i;
		for( i = 0; i < nend; i++ ) {
			max = *src;
			for( size_t s = 1; s < step - i - 1; s++ )
				max = max > *( src + s )? max:*(src + s );
			*dst++ = max;
			src++;
		}
	}

	void SIMD::dilateSpan1f( float* dst, const float* src, size_t n, size_t radius ) const
	{
		size_t i = 0;
		const size_t b2 = n - radius - 2;
		const size_t step = radius * 2 + 1;
		float max;

		if( radius == 0 ) {
			memcpy( dst, src, n * sizeof( float ) );
			return;
		}

		/* border 1 */
		/* find max in 0 to radius */
		max = *src;
		for( size_t s = 1; s <= radius; s++ )
			max = max > *( src + s )? max:*(src + s );
		*dst++ = max;

		/* update max by including src + radius + i and update dst */
		for( i = 1; i < radius; i++ ) {
			max = max > *( src + radius + i ) ? max : *( src + radius + i );
			*dst++ = max;
		}

		/* main part */
		for(; i <= b2; i += 2 ) {
			max = *( src + 1 );
			for( size_t s = 2; s < step; s++ ) {
				max = max > *( src + s ) ? max : *( src + s );
			}
			*dst++ = max > *src ? max : *src;
			*dst++ = max > *( src + step ) ? max : *( src + step );
			src += 2;
		}

		for( ; i < n - radius; i++ ) {
			max = *src;
			for( size_t s = 1; s < step; s++ ) {
				max = max > *( src + s ) ? max : *( src + s );
			}
			*dst++ = max > *src ? max : *src;
			src++;
		}

		/* border 2 */
		size_t nend = n - i;
		for( i = 0; i < nend; i++ ) {
			max = *src;
			for( size_t s = 1; s < step - i - 1; s++ )
				max = max > *( src + s )? max:*(src + s );
			*dst++ = max;
			src++;
		}
	}

    void SIMD::Conv_f_to_u8( uint8_t* dst, float const* src, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = ( uint8_t ) Math::clamp( *src++ * 255.0f + 0.5f, 0.0f, 255.0f );
            *dst++ = ( uint8_t ) Math::clamp( *src++ * 255.0f + 0.5f, 0.0f, 255.0f );
            *dst++ = ( uint8_t ) Math::clamp( *src++ * 255.0f + 0.5f, 0.0f, 255.0f );
            *dst++ = ( uint8_t ) Math::clamp( *src++ * 255.0f + 0.5f, 0.0f, 255.0f );
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = ( uint8_t ) Math::clamp( *src++ * 255.0f + 0.5f, 0.0f, 255.0f );
    }

    void SIMD::Conv_f_to_u16( uint16_t* dst, const float* src, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = ( uint16_t ) Math::clamp( *src++ * 65535.0f + 0.5f, 0.0f, 65535.0f );
            *dst++ = ( uint16_t ) Math::clamp( *src++ * 65535.0f + 0.5f, 0.0f, 65535.0f );
            *dst++ = ( uint16_t ) Math::clamp( *src++ * 65535.0f + 0.5f, 0.0f, 65535.0f );
            *dst++ = ( uint16_t ) Math::clamp( *src++ * 65535.0f + 0.5f, 0.0f, 65535.0f );
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = ( uint16_t ) Math::clamp( *src++ * 65535.0f + 0.5f, 0.0f, 65535.0f );
    }

    void SIMD::Conv_s16_to_u8( uint8_t* dst, int16_t const* src, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = ( uint8_t ) Math::clamp( *src++ >> 8, 0, 255 );
            *dst++ = ( uint8_t ) Math::clamp( *src++ >> 8, 0, 255 );
            *dst++ = ( uint8_t ) Math::clamp( *src++ >> 8, 0, 255 );
            *dst++ = ( uint8_t ) Math::clamp( *src++ >> 8, 0, 255 );
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = ( uint8_t ) Math::clamp( *src++ >> 8, 0, 255 );
    }

    void SIMD::Conv_GRAYALPHAf_to_GRAYf( float* dst, const float* src, const size_t n ) const
    {
        size_t i = n;
        while( i-- ) {
            *dst++ = *src++;
            src++;
        }
    }

    void SIMD::Conv_GRAYf_to_GRAYu8( uint8_t* dst, const float* src, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = F_TO_SRGB_U8( *src++ );
            *dst++ = F_TO_SRGB_U8( *src++ );
            *dst++ = F_TO_SRGB_U8( *src++ );
            *dst++ = F_TO_SRGB_U8( *src++ );
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = F_TO_SRGB_U8( *src++ );
    }

    void SIMD::Conv_fx_to_u8( uint8_t* dst, const Fixed* src, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = ( uint8_t ) Math::clamp( src->round(), 0x0, 0xff );
            src++;
            *dst++ = ( uint8_t ) Math::clamp( src->round(), 0x0, 0xff );
            src++;
            *dst++ = ( uint8_t ) Math::clamp( src->round(), 0x0, 0xff );
            src++;
            *dst++ = ( uint8_t ) Math::clamp( src->round(), 0x0, 0xff );
            src++;
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ = ( uint8_t ) Math::clamp( src->round(), 0x0, 0xff );
            src++;
        }
    }

    void SIMD::Conv_fx_to_s16( int16_t* dst, const Fixed* src, const size_t n ) const
    {
        size_t i = n >> 2;
        while( i-- ) {
            *dst++ = ( int16_t ) Math::clamp( ( *src++ ).native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( ( *src++ ).native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( ( *src++ ).native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( ( *src++ ).native() >> 8, INT16_MIN, INT16_MAX );
        }
        i = n & 0x03;
        while( i-- ) {
            *dst++ = ( int16_t ) Math::clamp( ( *src++ ).native() >> 8, INT16_MIN, INT16_MAX );
        }
    }

    void SIMD::Conv_u8_to_f( float* dst, uint8_t const* src, const size_t n ) const
    {
        size_t i = n >> 2;

        while( i-- ) {
            *dst++ = U8_TO_F( *src++ );
            *dst++ = U8_TO_F( *src++ );
            *dst++ = U8_TO_F( *src++ );
            *dst++ = U8_TO_F( *src++ );
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = U8_TO_F( *src++ );
    }


    void SIMD::Conv_u16_to_f( float* dst, uint16_t const* src, const size_t n ) const
    {
        size_t i = n >> 2;
        const float scale = 1.0f / ( float ) 0xffff;

        while( i-- ) {
            *dst++ = scale * ( float ) ( *src++ );
            *dst++ = scale * ( float ) ( *src++ );
            *dst++ = scale * ( float ) ( *src++ );
            *dst++ = scale * ( float ) ( *src++ );
        }
        i = n & 0x03;
        while( i-- )
            *dst++ = scale * ( float ) ( *src++ );
    }

    void SIMD::Conv_u16_to_u8( uint8_t* dst, const uint16_t* src, const size_t n ) const
    {

        size_t i = n >> 2;

        while( i-- ){
            *dst++ = *src++ >> 8;
            *dst++ = *src++ >> 8;
            *dst++ = *src++ >> 8;
            *dst++ = *src++ >> 8;
        }
        i = n & 0x03;
        while( i-- )
            *dst++ =  *src++ >> 8 ;
    }

    void SIMD::Conv_u16_to_XXXAu8( uint8_t* _dst, const uint16_t* src, const size_t n ) const
    {

        size_t i = n;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t tmp;
        uint8_t val;

        while( i-- ){
            tmp = 0xff000000;
            val = *src >> 8;
            tmp |= ( val );
            tmp |= ( val ) << 8;
            tmp |= ( val ) << 16;

            *dst++ = tmp;
            src++;
        }
    }

    void SIMD::Conv_GRAYu8_to_XXXAu8( uint8_t* _dst, const uint8_t* src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t tmp;

        while( i-- ){
            tmp = 0xff000000;
            tmp |= ( *src );
            tmp |= ( *src ) << 8;
            tmp |= ( *src++ ) << 16;

            *dst++ = tmp;
        }
    }

    void SIMD::Conv_GRAYf_to_XXXAf( float* dst, const float* src, const size_t n ) const
    {
        size_t i = n;
        float tmp;

        while( i-- ){
            tmp = *src++;
            *dst++ = tmp;
            *dst++ = tmp;
            *dst++ = tmp;
            *dst++ = 1.0f;
        }
    }

    void SIMD::Conv_XXXAf_to_XXXAu8( uint8_t* _dst, float const* src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t tmp;
        float __alpha;

        while( i-- ) {
            tmp = F_TO_SRGB_U8( *src++ );
            tmp |= F_TO_SRGB_U8( *src++ ) << 8;
            tmp |= F_TO_SRGB_U8( *src++ ) << 16;
            __alpha  = *( src++ );
            __alpha = Math::clamp( __alpha, 0.0f, 1.0f );
            tmp |= ( uint8_t ) ( ( __alpha * 255.0f + 0.5f ) ) << 24;
            *dst++ = tmp;
        }
    }


    void SIMD::Conv_XYZAf_to_ZYXAf( float* dst, float const* src, const size_t n ) const
    {
        size_t i = n;

        while( i-- ) {
            *dst++ = *( src + 2 );
            *dst++ = *( src + 1 );
            *dst++ = *( src );
            *dst++ = *( src + 3 );
            src += 4;
        }
    }

    void SIMD::Conv_XYZAf_to_ZYXAu8( uint8_t* _dst, float const* src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t tmp;
        float __alpha;

        while( i-- ) {
            tmp = F_TO_SRGB_U8( *src++ ) << 16;
            tmp |= F_TO_SRGB_U8( *src++ ) << 8;
            tmp |= F_TO_SRGB_U8( *src++ );
            __alpha  = *src++;
            __alpha = Math::clamp( __alpha, 0.0f, 1.0f );
            tmp |= ( uint8_t ) ( ( __alpha * 255.0f + 0.5f ) ) << 24;
            *dst++ = tmp;
        }
    }

    void SIMD::Conv_XXXAu8_to_XXXAf( float* dst, uint8_t const* _src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t tmp;

        while( i-- ) {
            tmp = *src++;
            *dst++ = SRGB_U8_TO_F( tmp & 0xff );
            *dst++ = SRGB_U8_TO_F( ( tmp >> 8 ) & 0xff );
            *dst++ = SRGB_U8_TO_F( ( tmp >> 16 ) & 0xff );
            *dst++ = U8_TO_F( tmp >> 24 );
        }
    }

    void SIMD::Conv_XXXu8_to_XXXAu8( uint8_t* dst, const uint8_t* src, size_t n ) const {
        while ( n-- ) {
            *dst++ = *src++;
            *dst++ = *src++;
            *dst++ = *src++;
            *dst++ = 255;
        }
    }

    void SIMD::Conv_XXXAu8_to_XXXu8( uint8_t* dst, const uint8_t* src, size_t n ) const {
        while ( n-- ) {
            *dst++ = *src++;
            *dst++ = *src++;
            *dst++ = *src++;
            src++;
        }
    }

    void SIMD::Conv_XXXf_to_XXXAf( float* dst, const float* src, size_t n ) const {
        while ( n-- ) {
            *dst++ = *src++;
            *dst++ = *src++;
            *dst++ = *src++;
            *dst++ = 1.0f;
        }
    }

    void SIMD::Conv_XXXAf_to_XXXf( float* dst, const float* src, size_t n ) const {
        while ( n-- ) {
            *dst++ = *src++;
            *dst++ = *src++;
            *dst++ = *src++;
            src++;
        }
    }

    void SIMD::Conv_XYZAu8_to_ZYXAf( float* dst, uint8_t const* _src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t tmp;

        while( i-- ) {
            tmp = *src++;
            *dst++ = SRGB_U8_TO_F( ( tmp >> 16 ) & 0xff );
            *dst++ = SRGB_U8_TO_F( ( tmp >> 8 ) & 0xff );
            *dst++ = SRGB_U8_TO_F( tmp & 0xff );
            *dst++ = U8_TO_F( tmp >> 24 );
        }
    }


    void SIMD::Conv_XYZAu8_to_ZYXAu8( uint8_t* _dst, uint8_t const* _src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t tmp1, tmp2;

        while( i-- ) {
            tmp1 = *src++;
            tmp2 = ( tmp1 & 0xff00ff00 );
            tmp2 += ( tmp1 & 0xff0000 ) >> 16;
            tmp2 += ( tmp1 & 0xff ) << 16;
            *dst++ = tmp2;
        }
    }

    void SIMD::Conv_RGBAu8_to_GRAYf( float* dst, uint8_t const* _src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t tmp;
        float v;

        while( i-- ) {
            tmp = *src++;
            v = 0.2126f * SRGB_U8_TO_F( tmp & 0xff );
            v += 0.7152f * SRGB_U8_TO_F( ( tmp >> 8 ) & 0xff );
            v += 0.0722f * SRGB_U8_TO_F( ( tmp >> 16 ) & 0xff );
            *dst++ = v;
        }
    }

    void SIMD::Conv_BGRAf_to_GRAYf( float* dst, const float* src, const size_t n ) const
    {
        size_t i = n;
        float v;

        while( i-- ) {
            v = 0.0722f * *src++;
            v += 0.7152f * *src++;
            v += 0.2126f * *src++;
            src++;
            *dst++ = v;
        }
    }

    void SIMD::Conv_RGBAf_to_GRAYf( float* dst, const float* src, const size_t n ) const
    {
        size_t i = n;
        float v;

        while( i-- ) {
            v = 0.2126f * *src++;
            v += 0.7152f * *src++;
            v += 0.0722f * *src++;
            src++;
            *dst++ = v;
        }
    }

    void SIMD::Conv_BGRAu8_to_GRAYf( float* dst, uint8_t const* _src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t tmp;
        float v;

        while( i-- ) {
            tmp = *src++;
            v = 0.2126f * SRGB_U8_TO_F( (tmp >> 16 ) & 0xff );
            v += 0.7152f * SRGB_U8_TO_F( ( tmp >> 8 ) & 0xff );
            v += 0.0722f * SRGB_U8_TO_F( ( tmp ) & 0xff );
            *dst++ = v;
        }
    }

    void SIMD::Conv_BGRAu8_to_GRAYu8( uint8_t* dst, const uint8_t * _src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t tmp;
        int v;

        while( i-- ) {
            tmp = *src++;
            v = 306 * ( ( tmp >>16 ) & 0xff );
            v += 601 * (  ( tmp >> 8 ) & 0xff );
            v += 117 * ( tmp & 0xff );
            *dst++ = ( uint8_t ) ( v >> 10 );
        }
    }

    void SIMD::Conv_RGBAu8_to_GRAYu8( uint8_t* dst, const uint8_t * _src, const size_t n ) const
    {
        size_t i = n;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t tmp;
        int v;

        while( i-- ) {
            tmp = *src++;
            v = 117 * ( ( tmp >>16 ) & 0xff );
            v += 601 * (  ( tmp >> 8 ) & 0xff );
            v += 306 * ( tmp & 0xff );
            *dst++ = ( uint8_t ) ( v >> 10 );
        }
    }

    void SIMD::Conv_YUYVu8_to_RGBAu8( uint8_t* _dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t yuyv, out;
        int r, g, b, y0, y1, u, v;

        while( n1-- ) {
            yuyv = *src++;
            v = ( yuyv >> 24 ) - 128;
            y1 = ( ( ( int ) ( ( yuyv >> 16 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            u = ( ( yuyv >> 8 ) & 0xff ) - 128;
            y0 = ( ( ( int ) ( yuyv & 0xff ) - 16 ) * 1192 ) >> 10;
            r = ( ( v * 1634 ) >> 10 );
            g = ( ( u * 401 + v*832 ) >> 10 );
            b = ( ( u * 2066 ) >> 10 );

            // clamp the values
            out = 0xff000000;
            out |= Math::clamp( y0 + r, 0, 255 );
            out |= Math::clamp( y0 - g, 0, 255 ) << 8;
            out |= Math::clamp( y0 + b, 0, 255 ) << 16;
            *dst++ = out;
            out = 0xff000000;
            out |= Math::clamp( y1 + r, 0, 255 );
            out |= Math::clamp( y1 - g, 0, 255 ) << 8;
            out |= Math::clamp( y1 + b, 0, 255 ) << 16;
            *dst++ = out;
        }
    }

    void SIMD::Conv_YUYVu8_to_BGRAu8( uint8_t* _dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t yuyv, out;
        int r, g, b, y0, y1, u, v;

        while( n1-- ) {
            yuyv = *src++;
            v = ( yuyv >> 24 ) - 128;
            y1 = ( ( ( int ) ( ( yuyv >> 16 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            u = ( ( yuyv >> 8 ) & 0xff ) - 128;
            y0 = ( ( ( int ) ( yuyv & 0xff ) - 16 ) * 1192 ) >> 10;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            // clamp the values
            out = 0xff000000;
            out |= Math::clamp( y0 + r, 0, 255 ) << 16;
            out |= Math::clamp( y0 - g, 0, 255 ) << 8;
            out |= Math::clamp( y0 + b, 0, 255 );
            *dst++ = out;
            out = 0xff000000;
            out |= Math::clamp( y1 + r, 0, 255 ) << 16;
            out |= Math::clamp( y1 - g, 0, 255 ) << 8;
            out |= Math::clamp( y1 + b, 0, 255 );
            *dst++ = out;
        }
    }

    void SIMD::Conv_UYVYu8_to_RGBAu8( uint8_t* _dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t uyvy, out;
        int r, g, b, y0, y1, u, v;

        while( n1-- ) {
            uyvy = *src++;
            v = ( ( uyvy >> 16 ) & 0xff ) - 128;
            y1 = ( ( ( int ) ( uyvy >> 24 ) - 16 ) * 1192 ) >> 10;
            u = ( uyvy & 0xff ) - 128;
            y0 = ( ( ( int ) ( ( uyvy >> 8 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            // clamp the values
            out = 0xff000000;
            out |= Math::clamp( y0 + r, 0, 255 );
            out |= Math::clamp( y0 - g, 0, 255 ) << 8;
            out |= Math::clamp( y0 + b, 0, 255 ) << 16;
            *dst++ = out;
            out = 0xff000000;
            out |= Math::clamp( y1 + r, 0, 255 );
            out |= Math::clamp( y1 - g, 0, 255 ) << 8;
            out |= Math::clamp( y1 + b, 0, 255 ) << 16;
            *dst++ = out;
        }
    }

    void SIMD::Conv_UYVYu8_to_BGRAu8( uint8_t* _dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t uyvy, out;
        int r, g, b, y0, y1, u, v;

        while( n1-- ) {
            uyvy = *src++;
            v = ( ( uyvy >> 16 ) & 0xff ) - 128;
            y1 = ( ( ( int ) ( uyvy >> 24 ) - 16 ) * 1192 ) >> 10;
            u = ( uyvy & 0xff ) - 128;
            y0 = ( ( ( int ) ( ( uyvy >> 8 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            // clamp the values
            out = 0xff000000;
            out |= Math::clamp( y0 + r, 0, 255 ) << 16;
            out |= Math::clamp( y0 - g, 0, 255 ) << 8;
            out |= Math::clamp( y0 + b, 0, 255 );
            *dst++ = out;
            out = 0xff000000;
            out |= Math::clamp( y1 + r, 0, 255 ) << 16;
            out |= Math::clamp( y1 - g, 0, 255 ) << 8;
            out |= Math::clamp( y1 + b, 0, 255 );
            *dst++ = out;
        }
    }

    void SIMD::Conv_YUYVu8_to_GRAYu8( uint8_t* dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t yuyv;
        int y0, y1;

        while( n1-- ) {
            yuyv = *src++;
            y1 = ( ( ( int ) ( ( yuyv >> 16 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            y0 = ( ( ( int ) ( yuyv & 0xff ) - 16 ) * 1192 ) >> 10;

            // clamp the values
            *dst++ = Math::clamp( y0, 0, 255 );
            *dst++ = Math::clamp( y1, 0, 255 );
        }
    }

    void SIMD::Conv_YUYVu8_to_GRAYf( float* dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t yuyv;
        int y0, y1;

        while( n1-- ) {
            yuyv = *src++;
            y1 = ( ( ( int ) ( ( yuyv >> 16 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            y0 = ( ( ( int ) ( yuyv & 0xff ) - 16 ) * 1192 ) >> 10;

            // clamp the values
            *dst++ = SRGB_U8_TO_F( Math::clamp( y0, 0, 255 ) );
            *dst++ = SRGB_U8_TO_F( Math::clamp( y1, 0, 255 ) );
        }
    }

    void SIMD::Conv_YUYVu8_to_GRAYALPHAu8( uint8_t* dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t yuyv;
        int y0, y1;

        while( n1-- ) {
            yuyv = *src++;
            y1 = ( ( ( int ) ( ( yuyv >> 16 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            y0 = ( ( ( int ) ( yuyv & 0xff ) - 16 ) * 1192 ) >> 10;

            // clamp the values
            *dst++ = Math::clamp( y0, 0, 255 );
            *dst++ = Math::clamp( y1, 0, 255 );
        }
    }

    void SIMD::Conv_UYVYu8_to_GRAYu8( uint8_t* dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t uyvy;
        int y0, y1;

        while( n1-- ) {
            uyvy = *src++;
            y1 = ( ( ( int ) ( uyvy >> 24 ) - 16 ) * 1192 ) >> 10;
            y0 = ( ( ( int ) ( ( uyvy >> 8 ) & 0xff ) - 16 ) * 1192 ) >> 10;

            // clamp the values
            *dst++ = Math::clamp( y0, 0, 255 );
            *dst++ = Math::clamp( y1, 0, 255 );
        }
    }

    void SIMD::Conv_UYVYu8_to_GRAYf( float* dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t uyvy;
        int y0, y1;

        while( n1-- ) {
            uyvy = *src++;
            y1 = ( ( ( int ) ( uyvy >> 24 ) - 16 ) * 1192 ) >> 10;
            y0 = ( ( ( int ) ( ( uyvy >> 8 ) & 0xff ) - 16 ) * 1192 ) >> 10;

            // clamp the values
            *dst++ = SRGB_U8_TO_F( Math::clamp( y0, 0, 255 ) );
            *dst++ = SRGB_U8_TO_F( Math::clamp( y1, 0, 255 ) );
        }
    }

    void SIMD::Conv_UYVYu8_to_GRAYALPHAu8( uint8_t* dst, const uint8_t* _src, const size_t n ) const
    {
        size_t n1 = n >> 1;
        uint32_t* src = ( uint32_t* ) _src;
        uint32_t uyvy;
        int y0, y1;

        while( n1-- ) {
            uyvy = *src++;
            y1 = ( ( ( int ) ( uyvy >> 24 ) - 16 ) * 1192 ) >> 10;
            y0 = ( ( ( int ) ( ( uyvy >> 8 ) & 0xff ) - 16 ) * 1192 ) >> 10;

            // clamp the values
            *dst++ = Math::clamp( y0, 0, 255 );
            *dst++ = 0xff;
            *dst++ = Math::clamp( y1, 0, 255 );
            *dst++ = 0xff;
        }
    }

    void SIMD::Conv_YUV420u8_to_RGBAu8( uint8_t* _dst, const uint8_t* _srcy, const uint8_t* srcu, const uint8_t* srcv, const size_t n ) const
    {
        size_t n1 = n >> 2;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t* srcy = ( uint32_t* ) _srcy;
        uint32_t y4, out;
        int r, g, b, y, u, v;

        while( n1-- ) {
            y4 = *srcy++;

            u = *srcu++ - 128;
            v = *srcv++ - 128;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            y = ( ( ( int ) ( y4 & 0xff ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 );
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 ) << 16;
            *dst++ = out;

            y = ( ( ( int ) ( ( y4 >> 8 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 );
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 ) << 16;
            *dst++ = out;

            u = *srcu++ - 128;
            v = *srcv++ - 128;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            y = ( ( ( int ) ( ( y4 >> 16 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 );
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 ) << 16;
            *dst++ = out;

            y = ( ( ( int ) ( y4 >> 24 ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 );
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 ) << 16;
            *dst++ = out;
        }

        if( n & 0x2 ) {
            _srcy = ( uint8_t* ) srcy;
            u = *srcu - 128;
            v = *srcv - 128;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            y = ( ( ( int ) *_srcy++ - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 );
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 ) << 16;
            *dst++ = out;

            y = ( ( ( int ) *_srcy++ - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 );
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 ) << 16;
            *dst++ = out;
        }
    }

    void SIMD::Conv_YUV420u8_to_BGRAu8( uint8_t* _dst, const uint8_t* _srcy, const uint8_t* srcu, const uint8_t* srcv, const size_t n ) const
    {
        size_t n1 = n >> 2;
        uint32_t* dst = ( uint32_t* ) _dst;
        uint32_t* srcy = ( uint32_t* ) _srcy;
        uint32_t y4, out;
        int r, g, b, y, u, v;

        while( n1-- ) {
            y4 = *srcy++;

            u = *srcu++ - 128;
            v = *srcv++ - 128;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            y = ( ( ( int ) ( y4 & 0xff ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 ) << 16;
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 );
            *dst++ = out;

            y = ( ( ( int ) ( ( y4 >> 8 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 ) << 16;
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 );
            *dst++ = out;

            u = *srcu++ - 128;
            v = *srcv++ - 128;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            y = ( ( ( int ) ( ( y4 >> 16 ) & 0xff ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 ) << 16;
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 );
            *dst++ = out;

            y = ( ( ( int ) ( y4 >> 24 ) - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 ) << 16;
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 );
            *dst++ = out;
        }

        if( n & 0x2 ) {
            _srcy = ( uint8_t* ) srcy;
            u = *srcu - 128;
            v = *srcv - 128;
            r = ((v*1634) >> 10);
            g = ((u*401 + v*832) >> 10);
            b = ((u*2066) >> 10);

            y = ( ( ( int ) *_srcy++ - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 ) << 16;
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 );
            *dst++ = out;

            y = ( ( ( int ) *_srcy++ - 16 ) * 1192 ) >> 10;
            out = 0xff000000;
            out |= Math::clamp( y + r, 0, 255 ) << 16;
            out |= Math::clamp( y - g, 0, 255 ) << 8;
            out |= Math::clamp( y + b, 0, 255 );
            *dst++ = out;
        }
    }

    void SIMD::Decompose_4f( float* dst1, float* dst2, float* dst3, float* dst4, const float* src, size_t n ) const
    {
        while( n-- ) {
            *dst1++ = *src++;
            *dst2++ = *src++;
            *dst3++ = *src++;
            *dst4++ = *src++;
        }
    }

    void SIMD::Decompose_4f_to_3f( float* dst1, float* dst2, float* dst3, const float* src, size_t n ) const
    {
        while( n-- ) {
            *dst1++ = *src++;
            *dst2++ = *src++;
            *dst3++ = *src++;
            src++;
        }
    }

    void SIMD::Decompose_2f( float* dst1, float* dst2, const float* src, size_t n ) const
     {
        while( n-- ) {
            *dst1++ = *src++;
            *dst2++ = *src++;
        }
    }

    void SIMD::Decompose_4u8( uint8_t* dst1, uint8_t* dst2, uint8_t* dst3, uint8_t* dst4, const uint8_t* src, size_t n ) const
    {
        while( n-- ) {
            *dst1++ = *src++;
            *dst2++ = *src++;
            *dst3++ = *src++;
            *dst4++ = *src++;
        }
    }

    void SIMD::Decompose_4u8_to_3u8( uint8_t* dst1, uint8_t* dst2, uint8_t* dst3, const uint8_t* src, size_t n ) const
    {
        while( n-- ) {
            *dst1++ = *src++;
            *dst2++ = *src++;
            *dst3++ = *src++;
            src++;
        }
    }

    void SIMD::Decompose_2u8( uint8_t* dst1, uint8_t* dst2, const uint8_t* src, size_t n ) const
    {
        while( n-- ) {
            *dst1++ = *src++;
            *dst2++ = *src++;
        }
    }

	void SIMD::BoxFilterHorizontal_1u8_to_f( float* dst, const uint8_t* src, size_t radius, size_t width ) const
	{
		size_t x;
		float accum;
		float invmean = 1.0f / ( float ) ( 2 * radius + 1 );

		accum = *src * ( float ) ( radius + 1 );
		for( x = 1; x <= radius; x++ )
			accum += ( float ) src[ x ];

		*dst++ = accum * invmean;

		for( x = 1; x <= radius; x++ ) {
			accum -= ( float ) src[ 0 ];
			accum += ( float ) src[ x + radius ];
			*dst++ = accum * invmean;
		}

		for( ; x < width - radius; x++ ) {
			accum -= ( float ) src[ x - radius - 1 ];
			accum += ( float ) src[ x + radius ];
			*dst++ = accum * invmean;
		}

		for( ; x < width; x++ ) {
			accum -= ( float ) src[ x - radius - 1 ];
			accum += ( float ) src[ width - 1 ];
			*dst++ = accum * invmean;
		}
	}

	void SIMD::BoxFilterHorizontal_1f( float* dst, const float* src, size_t radius, size_t width ) const
	{
		size_t x;
		float accum;
		float invmean = 1.0f / ( float ) ( 2 * radius + 1 );

		accum = *src * ( float ) ( radius + 1 );
		for( x = 1; x <= radius; x++ )
			accum += src[ x ];

		*dst++ = accum * invmean;

		for( x = 1; x <= radius; x++ ) {
			accum -= src[ 0 ];
			accum += src[ x + radius ];
			*dst++ = accum * invmean;
		}

		for( ; x < width - radius; x++ ) {
			accum -= src[ x - radius - 1 ];
			accum += src[ x + radius ];
			*dst++ = accum * invmean;
		}

		for( ; x < width; x++ ) {
			accum -= src[ x - radius - 1 ];
			accum += src[ width - 1 ];
			*dst++ = accum * invmean;
		}
	}


	void SIMD::BoxFilterVert_f_to_u8( uint8_t* dst, float* accum, const float* add, const float* sub, size_t radius, size_t width ) const
	{
		size_t x;

		float invmean = 1.0f / ( float ) ( 2 * radius + 1 );

		for( x = 0; x < width; x++ ) {
			float tmp;
			tmp = *accum + *add++ - *sub++;
			*accum++ = tmp;
            *dst++ = ( uint8_t ) Math::clamp( tmp * invmean, 0.0f, 255.0f );
		}
	}

	void SIMD::BoxFilterVert_f( float* dst, float* accum, const float* add, const float* sub, size_t radius, size_t width ) const
	{
		size_t x;

		float invmean = 1.0f / ( float ) ( 2 * radius + 1 );

		for( x = 0; x < width; x++ ) {
			float tmp;
			tmp = *accum + *add++ - *sub++;
			*accum++ = tmp;
            *dst++ = tmp * invmean;
		}
	}


    void SIMD::AddVert_f( float* dst, const float** bufs, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

        for( x = 0 ; x < width; x++ ) {
            tmp = bufs[ 0 ][ x ];

            for( size_t k = 1; k < numw; k++ ) {
                tmp += bufs[ k ][ x ];
            }
            *dst++ = tmp;
        }
    }

    void SIMD::AddVert_f_to_u8( uint8_t* dst, const float** bufs, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

        for( x = 0 ; x < width; x++ ) {
            tmp = bufs[ 0 ][ x ];

            for( size_t k = 1; k < numw; k++ ) {
                tmp += bufs[ k ][ x ];
            }
            *dst++ = ( uint8_t ) Math::clamp( tmp, 0.0f, 255.0f );
        }
    }

    void SIMD::AddVert_f_to_s16( int16_t* dst, const float** bufs, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

        for( x = 0 ; x < width; x++ ) {
            tmp = bufs[ 0 ][ x ];

            for( size_t k = 1; k < numw; k++ ) {
                tmp += bufs[ k ][ x ];
            }
            *dst++ = ( int16_t ) Math::clamp( tmp, ( float ) INT16_MIN, ( float ) INT16_MAX );
        }
    }

    void SIMD::AddVert_fx_to_u8( uint8_t* dst, const Fixed** bufs, size_t numw, size_t width ) const
    {
        size_t x;
        Fixed tmp;

        for( x = 0 ; x < width; x++ ) {
            tmp = bufs[ 0 ][ x ];

            for( size_t k = 1; k < numw; k++ ) {
                tmp += bufs[ k ][ x ];
            }

            *dst++ = ( uint8_t ) Math::clamp( tmp.round(), 0x0, 0xff );
        }
    }



	void SIMD::ConvolveHorizontal1f( float* dst, const float* src, const size_t width, float const* weights, const size_t wn, IBorderType btype ) const
	{
		if( wn == 1 ) {
			MulValue1f( dst, src, *weights, width );
			return;
		}

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = x - b1 + k;
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
	}

	void SIMD::ConvolveHorizontal2f( float* dst, const float* src, const size_t width, float const* weights, const size_t wn, IBorderType btype ) const
	{
		if( wn == 1 ) {
			MulValue1f( dst, src, *weights, width * 2 );
			return;
		}

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = ( x - b1 + k ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
	}

	void SIMD::ConvolveHorizontal4f( float* dst, const float* src, const size_t width, float const* weights, const size_t wn, IBorderType btype ) const
	{
		if( wn == 1 ) {
			MulValue1f( dst, src, *weights, width * 4 );
			return;
		}

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = ( x - b1 + k ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
	}

	void SIMD::ConvolveHorizontalSym1f( float* dst, const float* src, const size_t width, float const* weights, const size_t wn, IBorderType btype ) const
	{
		if( wn == 1 ) {
			MulValue1f( dst, src, *weights, width );
			return;
		}

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const float* wsym = weights + b1;


        for( x = 0; x < b1; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp;
			tmp = wsym[ 0 ] * src[ x ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k );
				ssize_t pos2 = ( x + k );
				tmp += wsym[ k ] * ( src[ pos1 ] + src[ pos2 ] );
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
	}

	void SIMD::ConvolveHorizontalSym2f( float* dst, const float* src, const size_t width, const float* weights, const size_t wn, IBorderType btype ) const
	{
		if( wn == 1 ) {
			MulValue1f( dst, src, *weights, width * 2 );
			return;
		}

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const float* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 2 ];
			ssize_t pos = ( x ) << 1;
			tmp[ 0 ] = wsym[ 0 ] * src[ pos + 0 ];
			tmp[ 1 ] = wsym[ 0 ] * src[ pos + 1 ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k ) << 1;
				ssize_t pos2 = ( x + k ) << 1;
				tmp[ 0 ] += wsym[ k ] * ( src[ pos1 + 0 ] + src[ pos2 + 0 ] );
				tmp[ 1 ] += wsym[ k ] * ( src[ pos1 + 1 ] + src[ pos2 + 1 ] );
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
	}

	void SIMD::ConvolveHorizontalSym4f( float* dst, const float* src, const size_t width, float const* weights, const size_t wn, IBorderType btype ) const
	{
		if( wn == 1 ) {
			MulValue1f( dst, src, *weights, width * 4 );
			return;
		}

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const float* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 4 ];
			ssize_t pos = ( x ) << 2;
			tmp[ 0 ] = wsym[ 0 ] * src[ pos + 0 ];
			tmp[ 1 ] = wsym[ 0 ] * src[ pos + 1 ];
			tmp[ 2 ] = wsym[ 0 ] * src[ pos + 2 ];
			tmp[ 3 ] = wsym[ 0 ] * src[ pos + 3 ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k ) << 2;
				ssize_t pos2 = ( x + k ) << 2;
				tmp[ 0 ] += wsym[ k ] * ( src[ pos1 + 0 ] + src[ pos2 + 0 ] );
				tmp[ 1 ] += wsym[ k ] * ( src[ pos1 + 1 ] + src[ pos2 + 1 ] );
				tmp[ 2 ] += wsym[ k ] * ( src[ pos1 + 2 ] + src[ pos2 + 2 ] );
				tmp[ 3 ] += wsym[ k ] * ( src[ pos1 + 3 ] + src[ pos2 + 3 ] );
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
		for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
	}

	void SIMD::ConvolveHorizontal1u8_to_fx( Fixed* dst, const uint8_t* src, const size_t width, const Fixed* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1fx( dst, src, *weights, width );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			Fixed tmp;
			tmp.native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			Fixed tmp;
			tmp.native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = x - b1 + k;
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			Fixed tmp;
			tmp.native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
	}

	void SIMD::ConvolveHorizontal2u8_to_fx( Fixed* dst, const uint8_t* src, const size_t width, const Fixed* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1fx( dst, src, *weights, width * 2 );
            return;
        }


		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			Fixed tmp[ 2 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
		for( ; x < ( ssize_t ) width - b2; x++ ) {

			Fixed tmp[ 2 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = ( x - b1 + k ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
			*dst++ = tmp[ 0 ];
			*dst++ = tmp[ 1 ];
		}
        for( ; x < ( ssize_t ) width; x++ ) {
			Fixed tmp[ 2 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
	}

	void SIMD::ConvolveHorizontal4u8_to_fx( Fixed* dst, const uint8_t* src, const size_t width, const Fixed* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1fx( dst, src, *weights, width * 4 );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			Fixed tmp[ 4 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			tmp[ 2 ].native() = 0;
			tmp[ 3 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			Fixed tmp[ 4 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			tmp[ 2 ].native() = 0;
			tmp[ 3 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = ( x - b1 + k ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			Fixed tmp[ 4 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			tmp[ 2 ].native() = 0;
			tmp[ 3 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }

	}

	void SIMD::ConvolveHorizontalSym1u8_to_fx( Fixed* dst, const uint8_t* src, const size_t width, const Fixed* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1fx( dst, src, *weights, width );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const Fixed* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			Fixed tmp;
			tmp.native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			Fixed tmp = wsym[ 0 ] * src[ x ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = x + k;
				ssize_t pos2 = x - k;
				Fixed val;
				val.native() = ( ( int32_t ) src[ pos1 ] + ( int32_t ) src[ pos2 ] ) << 16;
				tmp += wsym[ k ] * val;
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			Fixed tmp;
			tmp.native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
	}

	void SIMD::ConvolveHorizontalSym2u8_to_fx( Fixed* dst, const uint8_t* src, const size_t width, const Fixed* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1fx( dst, src, *weights, width * 2 );
            return;
        }


		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const Fixed* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			Fixed tmp[ 2 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			Fixed tmp[ 2 ];
			size_t pos = x << 1;
			tmp[ 0 ] = wsym[ 0 ] * src[ pos + 0 ];
			tmp[ 1 ] = wsym[ 0 ] * src[ pos + 1 ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k ) << 1;
				ssize_t pos2 = ( x + k ) << 1;
				Fixed val[ 2 ];
				val[ 0 ].native() = ( ( int32_t ) src[ pos1 + 0 ] + ( int32_t ) src[ pos2 + 0 ] ) << 16;
				val[ 1 ].native() = ( ( int32_t ) src[ pos1 + 1 ] + ( int32_t ) src[ pos2 + 1 ] ) << 16;
				tmp[ 0 ] += wsym[ k ] * val[ 0 ];
				tmp[ 1 ] += wsym[ k ] * val[ 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];

        }
        for( ; x < ( ssize_t ) width; x++ ) {
			Fixed tmp[ 2 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
	}

	void SIMD::ConvolveHorizontalSym4u8_to_fx( Fixed* dst, const uint8_t* src, const size_t width, const Fixed* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1fx( dst, src, *weights, width * 4 );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const Fixed* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			Fixed tmp[ 4 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			tmp[ 2 ].native() = 0;
			tmp[ 3 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			Fixed tmp[ 4 ];
			ssize_t pos = ( x ) << 2;
			tmp[ 0 ] = wsym[ 0 ] * src[ pos + 0 ];
			tmp[ 1 ] = wsym[ 0 ] * src[ pos + 1 ];
			tmp[ 2 ] = wsym[ 0 ] * src[ pos + 2 ];
			tmp[ 3 ] = wsym[ 0 ] * src[ pos + 3 ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k ) << 2;
				ssize_t pos2 = ( x + k ) << 2;
				Fixed val[ 4 ];
				val[ 0 ].native() = ( ( int32_t ) src[ pos1 + 0 ] + ( int32_t ) src[ pos2 + 0 ] ) << 16;
				val[ 1 ].native() = ( ( int32_t ) src[ pos1 + 1 ] + ( int32_t ) src[ pos2 + 1 ] ) << 16;
				val[ 2 ].native() = ( ( int32_t ) src[ pos1 + 2 ] + ( int32_t ) src[ pos2 + 2 ] ) << 16;
				val[ 3 ].native() = ( ( int32_t ) src[ pos1 + 3 ] + ( int32_t ) src[ pos2 + 3 ] ) << 16;
				tmp[ 0 ] += wsym[ k ] * val[ 0 ];
				tmp[ 1 ] += wsym[ k ] * val[ 1 ];
				tmp[ 2 ] += wsym[ k ] * val[ 2 ];
				tmp[ 3 ] += wsym[ k ] * val[ 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			Fixed tmp[ 4 ];
			tmp[ 0 ].native() = 0;
			tmp[ 1 ].native() = 0;
			tmp[ 2 ].native() = 0;
			tmp[ 3 ].native() = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }

	}

	void SIMD::ConvolveHorizontal1u8_to_f( float* dst, const uint8_t* src, const size_t width, const float* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1f( dst, src, *weights, width );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = x - b1 + k;
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
	}

	void SIMD::ConvolveHorizontal2u8_to_f( float* dst, const uint8_t* src, const size_t width, const float* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1f( dst, src, *weights, width * 2 );
            return;
        }


		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = ( x - b1 + k ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
	}

	void SIMD::ConvolveHorizontal4u8_to_f( float* dst, const uint8_t* src, const size_t width, const float* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1f( dst, src, *weights, width * 4 );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = ( x - b1 + k ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }

	}

	void SIMD::ConvolveHorizontalSym1u8_to_f( float* dst, const uint8_t* src, const size_t width, const float* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1f( dst, src, *weights, width );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const float* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp;
			tmp = wsym[ 0 ] * src[ x ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k );
				ssize_t pos2 = ( x + k );
				tmp += wsym[ k ] * ( src[ pos1 ] + src[ pos2 ] );
			}
            *dst++ = tmp;
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp = 0;
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype );
				tmp += weights[ k ] * src[ pos ];
			}
            *dst++ = tmp;
        }
	}

	void SIMD::ConvolveHorizontalSym2u8_to_f( float* dst, const uint8_t* src, const size_t width, const float* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1f( dst, src, *weights, width * 2 );
            return;
        }


		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const float* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 2 ];
			ssize_t pos = ( x ) << 1;
			tmp[ 0 ] = wsym[ 0 ] * src[ pos + 0 ];
			tmp[ 1 ] = wsym[ 0 ] * src[ pos + 1 ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k ) << 1;
				ssize_t pos2 = ( x + k ) << 1;
				tmp[ 0 ] += wsym[ k ] * ( src[ pos1 + 0 ] + src[ pos2 + 0 ] );
				tmp[ 1 ] += wsym[ k ] * ( src[ pos1 + 1 ] + src[ pos2 + 1 ] );
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 2 ] = { 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 1;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
        }
	}

	void SIMD::ConvolveHorizontalSym4u8_to_f( float* dst, const uint8_t* src, const size_t width, const float* weights, const size_t wn, IBorderType btype ) const
	{
        if( wn == 1 ) {
            MulU8Value1f( dst, src, *weights, width * 4 );
            return;
        }

		ssize_t b1 = ( wn >> 1 );
		ssize_t b2 = wn - b1 - 1;
		ssize_t x;
		const float* wsym = weights + b1;

        for( x = 0; x < b1; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width - b2; x++ ) {
			float tmp[ 4 ];
			ssize_t pos = ( x ) << 2;
			tmp[ 0 ] = wsym[ 0 ] * src[ pos + 0 ];
			tmp[ 1 ] = wsym[ 0 ] * src[ pos + 1 ];
			tmp[ 2 ] = wsym[ 0 ] * src[ pos + 2 ];
			tmp[ 3 ] = wsym[ 0 ] * src[ pos + 3 ];
			for( ssize_t k = 1; k <= b1; k++ ) {
				ssize_t pos1 = ( x - k ) << 2;
				ssize_t pos2 = ( x + k ) << 2;
				tmp[ 0 ] += wsym[ k ] * ( src[ pos1 + 0 ] + src[ pos2 + 0 ] );
				tmp[ 1 ] += wsym[ k ] * ( src[ pos1 + 1 ] + src[ pos2 + 1 ] );
				tmp[ 2 ] += wsym[ k ] * ( src[ pos1 + 2 ] + src[ pos2 + 2 ] );
				tmp[ 3 ] += wsym[ k ] * ( src[ pos1 + 3 ] + src[ pos2 + 3 ] );
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }
        for( ; x < ( ssize_t ) width; x++ ) {
			float tmp[ 4 ] = { 0, 0, 0, 0 };
			for( size_t k = 0; k < wn; k++ ) {
				ssize_t pos = IBorder::value<ssize_t>( x - b1 + k, width, btype ) << 2;
				tmp[ 0 ] += weights[ k ] * src[ pos + 0 ];
				tmp[ 1 ] += weights[ k ] * src[ pos + 1 ];
				tmp[ 2 ] += weights[ k ] * src[ pos + 2 ];
				tmp[ 3 ] += weights[ k ] * src[ pos + 3 ];
			}
            *dst++ = tmp[ 0 ];
            *dst++ = tmp[ 1 ];
            *dst++ = tmp[ 2 ];
            *dst++ = tmp[ 3 ];
        }

	}

    void SIMD::ConvolveClampVert_fx_to_u8( uint8_t* dst, const Fixed** bufs, const Fixed* weights, size_t numw, size_t width ) const
    {
        Fixed tmp[ 8 ];
        size_t x;

        for( x = 0; x <= width - 8; x += 8 ) {
            tmp[ 0 ] = bufs[ 0 ][ x + 0 ] * *weights;
            tmp[ 1 ] = bufs[ 0 ][ x + 1 ] * *weights;
            tmp[ 2 ] = bufs[ 0 ][ x + 2 ] * *weights;
            tmp[ 3 ] = bufs[ 0 ][ x + 3 ] * *weights;
            tmp[ 4 ] = bufs[ 0 ][ x + 4 ] * *weights;
            tmp[ 5 ] = bufs[ 0 ][ x + 5 ] * *weights;
            tmp[ 6 ] = bufs[ 0 ][ x + 6 ] * *weights;
            tmp[ 7 ] = bufs[ 0 ][ x + 7 ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp[ 0 ] += bufs[ k ][ x + 0 ] * weights[ k ];
                tmp[ 1 ] += bufs[ k ][ x + 1 ] * weights[ k ];
                tmp[ 2 ] += bufs[ k ][ x + 2 ] * weights[ k ];
                tmp[ 3 ] += bufs[ k ][ x + 3 ] * weights[ k ];
                tmp[ 4 ] += bufs[ k ][ x + 4 ] * weights[ k ];
                tmp[ 5 ] += bufs[ k ][ x + 5 ] * weights[ k ];
                tmp[ 6 ] += bufs[ k ][ x + 6 ] * weights[ k ];
                tmp[ 7 ] += bufs[ k ][ x + 7 ] * weights[ k ];
            }
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 0 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 1 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 2 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 3 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 4 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 5 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 6 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 7 ].round(), 0x0, 0xff );
        }

        for( ; x <= width - 4; x += 4 ) {
            tmp[ 0 ] = bufs[ 0 ][ x + 0 ] * *weights;
            tmp[ 1 ] = bufs[ 0 ][ x + 1 ] * *weights;
            tmp[ 2 ] = bufs[ 0 ][ x + 2 ] * *weights;
            tmp[ 3 ] = bufs[ 0 ][ x + 3 ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp[ 0 ] += bufs[ k ][ x + 0 ] * weights[ k ];
                tmp[ 1 ] += bufs[ k ][ x + 1 ] * weights[ k ];
                tmp[ 2 ] += bufs[ k ][ x + 2 ] * weights[ k ];
                tmp[ 3 ] += bufs[ k ][ x + 3 ] * weights[ k ];
            }
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 0 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 1 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 2 ].round(), 0x0, 0xff );
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 3 ].round(), 0x0, 0xff );
        }

        for( ; x < width; x++ ) {
            tmp[ 0 ] = bufs[ 0 ][ x + 0 ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp[ 0 ] += bufs[ k ][ x + 0 ] * weights[ k ];
            }
            *dst++ = ( uint8_t ) Math::clamp( tmp[ 0 ].round(), 0x0, 0xff );
        }
    }

    void SIMD::ConvolveClampVert_fx_to_s16( int16_t* dst, const Fixed** bufs, const Fixed* weights, size_t numw, size_t width ) const
    {
        Fixed tmp[ 8 ];
        size_t x;

        for( x = 0; x <= width - 8; x += 8 ) {
            tmp[ 0 ] = bufs[ 0 ][ x + 0 ] * *weights;
            tmp[ 1 ] = bufs[ 0 ][ x + 1 ] * *weights;
            tmp[ 2 ] = bufs[ 0 ][ x + 2 ] * *weights;
            tmp[ 3 ] = bufs[ 0 ][ x + 3 ] * *weights;
            tmp[ 4 ] = bufs[ 0 ][ x + 4 ] * *weights;
            tmp[ 5 ] = bufs[ 0 ][ x + 5 ] * *weights;
            tmp[ 6 ] = bufs[ 0 ][ x + 6 ] * *weights;
            tmp[ 7 ] = bufs[ 0 ][ x + 7 ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp[ 0 ] += bufs[ k ][ x + 0 ] * weights[ k ];
                tmp[ 1 ] += bufs[ k ][ x + 1 ] * weights[ k ];
                tmp[ 2 ] += bufs[ k ][ x + 2 ] * weights[ k ];
                tmp[ 3 ] += bufs[ k ][ x + 3 ] * weights[ k ];
                tmp[ 4 ] += bufs[ k ][ x + 4 ] * weights[ k ];
                tmp[ 5 ] += bufs[ k ][ x + 5 ] * weights[ k ];
                tmp[ 6 ] += bufs[ k ][ x + 6 ] * weights[ k ];
                tmp[ 7 ] += bufs[ k ][ x + 7 ] * weights[ k ];
            }
            *dst++ = ( int16_t ) Math::clamp( tmp[ 0 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 1 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 2 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 3 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 4 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 5 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 6 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 7 ].native() >> 8, INT16_MIN, INT16_MAX );
        }

        for( ; x <= width - 4; x += 4 ) {
            tmp[ 0 ] = bufs[ 0 ][ x + 0 ] * *weights;
            tmp[ 1 ] = bufs[ 0 ][ x + 1 ] * *weights;
            tmp[ 2 ] = bufs[ 0 ][ x + 2 ] * *weights;
            tmp[ 3 ] = bufs[ 0 ][ x + 3 ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp[ 0 ] += bufs[ k ][ x + 0 ] * weights[ k ];
                tmp[ 1 ] += bufs[ k ][ x + 1 ] * weights[ k ];
                tmp[ 2 ] += bufs[ k ][ x + 2 ] * weights[ k ];
                tmp[ 3 ] += bufs[ k ][ x + 3 ] * weights[ k ];
            }
            *dst++ = ( int16_t ) Math::clamp( tmp[ 0 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 1 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 2 ].native() >> 8, INT16_MIN, INT16_MAX );
            *dst++ = ( int16_t ) Math::clamp( tmp[ 3 ].native() >> 8, INT16_MIN, INT16_MAX );
        }

        for( ; x < width; x++ ) {
            tmp[ 0 ] = bufs[ 0 ][ x + 0 ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp[ 0 ] += bufs[ k ][ x + 0 ] * weights[ k ];
            }
            *dst++ = ( int16_t ) Math::clamp( tmp[ 0 ].native() >> 8, INT16_MIN, INT16_MAX );
        }
    }

    void SIMD::ConvolveClampVert_f( float* dst, const float** bufs, const float* weights, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

        for( x = 0 ; x < width; x++ ) {
            tmp = bufs[ 0 ][ x ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp += bufs[ k ][ x ] * weights[ k ];
            }
            *dst++ = tmp;
        }
    }

    void SIMD::ConvolveClampVert_f_to_u8( uint8_t* dst, const float** bufs, const float* weights, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

        for( x = 0 ; x < width; x++ ) {
            tmp = bufs[ 0 ][ x ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp += bufs[ k ][ x ] * weights[ k ];
            }
            *dst++ = ( uint8_t ) Math::clamp( tmp, 0.0f, 255.0f );
        }
    }

    void SIMD::ConvolveClampVert_f_to_s16( int16_t* dst, const float** bufs, const float* weights, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

        for( x = 0 ; x < width; x++ ) {
            tmp = bufs[ 0 ][ x ] * *weights;

            for( size_t k = 1; k < numw; k++ ) {
                tmp += bufs[ k ][ x ] * weights[ k ];
            }
            *dst++ = ( int16_t ) Math::clamp( tmp, ( float ) INT16_MIN, ( float ) INT16_MAX );
        }
    }

	void SIMD::ConvolveClampVertSym_fx_to_u8( uint8_t* dst, const Fixed** bufs, const Fixed* weights, size_t numw, size_t width ) const
	{
		size_t x;
		Fixed tmp;

		ssize_t b1 = ( numw >> 1 );
		const Fixed* wsym = weights + b1;

		for( x = 0 ; x < width; x++ ) {
			tmp = wsym[ 0 ] * bufs[ b1 ][ x ];

			for( ssize_t k = 1; k <= b1; k++ ) {
				tmp += wsym[ k ] * ( bufs[ b1 + k ][ x ] + bufs[ b1 - k ][ x ] );
			}

            *dst++ = ( uint8_t ) Math::clamp( tmp.round(), 0x0, 0xff );
		}
	}

    void SIMD::ConvolveClampVertSym_f( float* dst, const float** bufs, const float* weights, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

		ssize_t b1 = ( numw >> 1 );
		const float* wsym = weights + b1;

        for( x = 0 ; x < width; x++ ) {
            tmp = wsym[ 0 ] * bufs[ b1 ][ x ];

            for( ssize_t k = 1; k <= b1; k++ ) {
                tmp += wsym[ k ] * ( bufs[ b1 + k ][ x ] + bufs[ b1 - k ][ x ] );
            }
            *dst++ = tmp;
        }
    }

    void SIMD::ConvolveClampVertSym_f_to_u8( uint8_t* dst, const float** bufs, const float* weights, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

		ssize_t b1 = ( numw >> 1 );
		const float* wsym = weights + b1;

        for( x = 0 ; x < width; x++ ) {
            tmp = wsym[ 0 ] * bufs[ b1 ][ x ];

            for( ssize_t k = 1; k <= b1; k++ ) {
                tmp += wsym[ k ] * ( bufs[ b1 + k ][ x ] + bufs[ b1 - k ][ x ] );
            }
            *dst++ = ( uint8_t ) Math::clamp( tmp, 0.0f, 255.0f );
        }
    }

    void SIMD::ConvolveClampVertSym_f_to_s16( int16_t* dst, const float** bufs, const float* weights, size_t numw, size_t width ) const
    {
        size_t x;
        float tmp;

		ssize_t b1 = ( numw >> 1 );
		const float* wsym = weights + b1;

        for( x = 0 ; x < width; x++ ) {
            tmp = wsym[ 0 ] * bufs[ b1 ][ x ];

            for( ssize_t k = 1; k <= b1; k++ ) {
                tmp += wsym[ k ] * ( bufs[ b1 + k ][ x ] + bufs[ b1 - k ][ x ] );
            }
            *dst++ = ( int16_t ) Math::clamp( tmp, ( float ) INT16_MIN, ( float ) INT16_MAX );
        }
    }


    void SIMD::ConvolveAdaptiveClamp1f( float* _dst, float const* _src, const size_t w, IConvolveAdaptivef* conva ) const
    {
        IConvolveAdaptiveSize* sw;
        float* weights;
        uint32_t x;
        float pixel;
        float* dst = ( float* ) _dst;
        float* src = ( float* ) _src;
        size_t width = w;

        sw = conva->size;
        weights = conva->weights;

        while( width-- ) {
            pixel = 0;
            src += sw->incr;
            for( x = 0; x < sw->numw; x++ ) {
                pixel += *( src + x ) * *weights++;
            }
            *dst++ = pixel;
            sw++;
        }
    }

    void SIMD::ConvolveAdaptiveClamp2f( float* _dst, float const* _src, const size_t w, IConvolveAdaptivef* conva ) const
    {
        IConvolveAdaptiveSize* sw;
        float* weights;
        uint32_t x;
        float pixel[ 2 ];
        float* dst = ( float* ) _dst;
        float* src = ( float* ) _src;
        size_t width = w;

        sw = conva->size;
        weights = conva->weights;

        while( width-- ) {
            pixel[ 0 ] = 0.0f;
            pixel[ 1 ] = 0.0f;
            src += sw->incr * 2;
            for( x = 0; x < sw->numw; x++ ) {
                pixel[ 0 ] += *( src + x * 2 + 0 ) * *weights;
                pixel[ 1 ] += *( src + x * 2 + 1 ) * *weights++;
            }
            *dst++ = pixel[ 0 ];
            *dst++ = pixel[ 1 ];
            sw++;
        }
    }

    void SIMD::ConvolveAdaptiveClamp4f( float* _dst, float const* _src, const size_t w, IConvolveAdaptivef* conva ) const
    {
        IConvolveAdaptiveSize* sw;
        float* weights;
        uint32_t x;
        float pixel[ 4 ];
        float* dst = ( float* ) _dst;
        float* src = ( float* ) _src;
        size_t width = w;

        sw = conva->size;
        weights = conva->weights;

        while( width-- ) {
            pixel[ 0 ] = 0.0f;
            pixel[ 1 ] = 0.0f;
            pixel[ 2 ] = 0.0f;
            pixel[ 3 ] = 0.0f;
            src += sw->incr * 4;
            for( x = 0; x < sw->numw; x++ ) {
                pixel[ 0 ] += *( src + x * 4 + 0 ) * *weights;
                pixel[ 1 ] += *( src + x * 4 + 1 ) * *weights;
                pixel[ 2 ] += *( src + x * 4 + 2 ) * *weights;
                pixel[ 3 ] += *( src + x * 4 + 3 ) * *weights++;
            }
            *dst++ = pixel[ 0 ];
            *dst++ = pixel[ 1 ];
            *dst++ = pixel[ 2 ];
            *dst++ = pixel[ 3 ];
            sw++;
        }
    }

    void SIMD::ConvolveAdaptive1Fixed( Fixed* _dst, uint8_t const* _src, size_t width, IConvolveAdaptiveFixed* conva ) const
    {
        IConvolveAdaptiveSize* sw;
        Fixed* weights;
        uint32_t x;

        Fixed pixel;
        Fixed* dst = _dst;
        const uint8_t* src = _src;

        sw = conva->size;
        weights = conva->weights;

        while( width-- ) {
            pixel = 0.0f;
            src += sw->incr;
            for( x = 0; x < sw->numw; x++ ) {
                pixel +=  ( *weights++ * *( src + x ) );
            }
            *dst++ = pixel;
            sw++;
        }
    }

    void SIMD::ConvolveAdaptive2Fixed( Fixed* _dst, uint8_t const* _src, size_t width, IConvolveAdaptiveFixed* conva ) const
    {
        IConvolveAdaptiveSize* sw;
        Fixed* weights;
        uint32_t x;
        Fixed pixel[ 2 ];
        Fixed* dst = _dst;
        const uint8_t* src = _src;

        sw = conva->size;
        weights = conva->weights;

        while( width-- ) {
            pixel[ 0 ] = 0.0f;
            pixel[ 1 ] = 0.0f;
            src += sw->incr * 2;
            for( x = 0; x < sw->numw; x++ ) {
                pixel[ 0 ] += *weights * *( src + x * 2 + 0 );
                pixel[ 1 ] += *weights++ * *( src + x * 2 + 1 );
            }
            *dst++ = pixel[ 0 ];
            *dst++ = pixel[ 1 ];
            sw++;
        }
    }

    void SIMD::ConvolveAdaptive4Fixed( Fixed* _dst, uint8_t const* _src, size_t width, IConvolveAdaptiveFixed* conva ) const
    {
        IConvolveAdaptiveSize* sw;
        Fixed* weights;
        uint32_t x;
        Fixed pixel[ 4 ];
        Fixed* dst = _dst;
        const uint8_t* src = _src;

        sw = conva->size;
        weights = conva->weights;

        while( width-- ) {
            pixel[ 0 ] = 0.0f;
            pixel[ 1 ] = 0.0f;
            pixel[ 2 ] = 0.0f;
            pixel[ 3 ] = 0.0f;
            src += sw->incr * 4;
            for( x = 0; x < sw->numw; x++ ) {
                pixel[ 0 ] += *weights * *( src + x * 4 + 0 );
                pixel[ 1 ] += *weights * *( src + x * 4 + 1 );
                pixel[ 2 ] += *weights * *( src + x * 4 + 2 );
                pixel[ 3 ] += *weights++ * *( src + x * 4 + 3 );
            }
            *dst++ = pixel[ 0 ];
            *dst++ = pixel[ 1 ];
            *dst++ = pixel[ 2 ];
            *dst++ = pixel[ 3 ];
            sw++;
        }
    }

    void SIMD::pyrdownHalfHorizontal_1u8_to_1u16( uint16_t* dst, const uint8_t* src, size_t n ) const
    {
        *dst++ =  ( ( ( uint16_t ) *( src + 1 ) ) << 2 ) + ( ( ( uint16_t ) *( src + 1 ) ) << 1 ) +
            ( ( ( uint16_t ) *( src ) + ( uint16_t ) *( src + 2 ) ) << 2 ) +
            ( ( ( uint16_t ) *( src + 3 ) ) << 1 );

        src += 3;
        if( n >= 6 ) {
            size_t n2 = ( n >> 1 ) - 2;

            while( n2-- ) {
                *dst++ = ( ( ( ( uint16_t ) *src ) << 2 ) + ( ( ( uint16_t ) *src ) << 1 ) +
                          ( ( ( uint16_t ) *( src + 1 ) ) << 2 ) + ( ( ( uint16_t ) *( src - 1 ) ) << 2 ) +
                          ( uint16_t ) *( src + 2 ) + ( uint16_t ) *( src - 2 ) );
                src += 2;
            }
        }

        if( n & 1 ) {
            *dst++ = ( ( ( uint16_t ) *src ) << 2 ) + ( ( ( uint16_t ) *src ) << 1 ) + ( ( ( uint16_t ) *( src - 2 ) ) << 1 ) +
                ( ( ( uint16_t ) *( src + 1 ) ) << 2 ) + ( ( ( uint16_t ) *( src - 1 ) ) << 2 );
        } else {
            *dst++ = ( ( ( uint16_t ) *src ) << 2 ) +
                ( ( ( uint16_t ) *src ) << 1 ) +
                ( ( ( ( ( uint16_t ) *( src - 1 ) ) << 2 ) +
                   ( uint16_t ) *( src - 2 ) ) << 1 );

        }
    }

    void SIMD::pyrdownHalfVertical_1u16_to_1u8( uint8_t* dst, uint16_t* rows[ 5 ], size_t n ) const
    {
        uint16_t tmp;
        uint16_t* src1 = rows[ 0 ];
        uint16_t* src2 = rows[ 1 ];
        uint16_t* src3 = rows[ 2 ];
        uint16_t* src4 = rows[ 3 ];
        uint16_t* src5 = rows[ 4 ];

        while( n-- ) {
            tmp = *src1++ + *src5++ + ( ( *src2++ + *src4++ ) << 2 ) + 6 * *src3++;
            *dst++ = ( uint8_t ) ( tmp >> 8 );
        }
    }

    void SIMD::warpLinePerspectiveBilinear1f( float* dst, const float* _src, size_t srcStride, size_t srcWidth, size_t srcHeight, const float* point, const float* direction, const size_t n ) const
    {
        const uint8_t* src = ( const uint8_t* ) _src;
        float px, py, pz;
        size_t i = n;

        px = point[ 0 ];
        py = point[ 1 ];
        pz = point[ 2 ];

        while( i-- )
        {
            float fx, fy;

            fx = px / pz;
            fy = py / pz;

            float alpha1 = fx + 1 - ( float ) ( int )( fx + 1 );
            float alpha2 = fy + 1 - ( float ) ( int )( fy + 1 );
#define VAL( fx, fy ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( float* ) ( src + srcStride * ( fy ) + sizeof( float ) * ( fx ) ) ) : *dst
            float v1, v2;
            int lx = -1 + ( int )( fx + 1 );
            int ly = -1 + ( int )( fy + 1 );
            v1 = Math::mix( VAL( lx, ly ), VAL( 1 + lx, ly  ), alpha1 );
            v2 = Math::mix( VAL( lx, 1 + ly ), VAL( 1 + lx, 1 + ly  ), alpha1 );
            *dst++ = Math::mix( v1, v2, alpha2 );
            px += direction[ 0 ];
            py += direction[ 1 ];
            pz += direction[ 2 ];
#undef VAL
        }

    }

    void SIMD::warpLinePerspectiveBilinear4f( float* dst, const float* _src, size_t srcStride, size_t srcWidth, size_t srcHeight, const float* point, const float* direction, const size_t n ) const
    {
        const uint8_t* src = ( const uint8_t* ) _src;
        float px, py, pz;
        size_t i = n;

        px = point[ 0 ];
        py = point[ 1 ];
        pz = point[ 2 ];

        while( i-- )
        {
            float fx, fy;

            fx = px / pz;
            fy = py / pz;

            float alpha1 = fx + 1 - ( float ) ( int )( fx + 1 );
            float alpha2 = fy + 1 - ( float ) ( int )( fy + 1 );
#define VAL( fx, fy, offset ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( float* ) ( src + srcStride * ( fy ) + sizeof( float ) * ( ( fx ) * 4 + offset ) ) ) : *dst
            float v1, v2;
            int lx = -1 + ( int )( fx + 1 );
            int ly = -1 + ( int )( fy + 1 );
            v1 = Math::mix( VAL( lx, ly, 0 ), VAL( 1 + lx, ly, 0 ), alpha1 );
            v2 = Math::mix( VAL( lx, 1 + ly, 0 ), VAL( 1 + lx, 1 + ly, 0 ), alpha1 );
            *dst++ = Math::mix( v1, v2, alpha2 );
            v1 = Math::mix( VAL( lx, ly, 1 ), VAL( 1 + lx, ly, 1 ), alpha1 );
            v2 = Math::mix( VAL( lx, 1 + ly, 1 ), VAL( 1 + lx, 1 + ly, 1 ), alpha1 );
            *dst++ = Math::mix( v1, v2, alpha2 );
            v1 = Math::mix( VAL( lx, ly, 2 ), VAL( 1 + lx, ly, 2 ), alpha1 );
            v2 = Math::mix( VAL( lx, 1 + ly, 2 ), VAL( 1 + lx, 1 + ly, 2 ), alpha1 );
            *dst++ = Math::mix( v1, v2, alpha2 );
            v1 = Math::mix( VAL( lx, ly, 3 ), VAL( 1 + lx, ly, 3 ), alpha1 );
            v2 = Math::mix( VAL( lx, 1 + ly, 3 ), VAL( 1 + lx, 1 + ly, 3 ), alpha1 );
            *dst++ = Math::mix( v1, v2, alpha2 );

            px += direction[ 0 ];
            py += direction[ 1 ];
            pz += direction[ 2 ];
#undef VAL
        }

    }

    void SIMD::warpLinePerspectiveBilinear1u8( uint8_t* dst, const uint8_t* _src, size_t srcStride, size_t srcWidth, size_t srcHeight, const float* point, const float* direction, const size_t n ) const
    {
        const uint8_t* src = ( const uint8_t* ) _src;
        float px, py, pz;
        size_t i = n;
        Fixed one( ( int16_t ) 1 );

        px = point[ 0 ];
        py = point[ 1 ];
        pz = point[ 2 ];

        while( i-- )
        {
            float fx, fy;

            fx = px / pz;
            fy = py / pz;

            float alpha1 = fx + 1 - ( float ) ( int )( fx + 1 );
            float alpha2 = fy + 1 - ( float ) ( int )( fy + 1 );

    #define VAL( fx, fy ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( uint8_t* ) ( src + srcStride * ( fy ) + sizeof( uint8_t ) * ( fx ) ) ) : *dst

            int lx = -1 + ( int )( fx + 1 );
            int ly = -1 + ( int )( fy + 1 );
            float v1 = Math::mix<float>( VAL( lx, ly ), VAL( 1 + lx, ly  ), alpha1 );
            float v2 = Math::mix<float>( VAL( lx, 1 + ly ), VAL( 1 + lx, 1 + ly  ), alpha1 );
            *dst++ =  ( uint8_t ) Math::clamp<int>( Math::mix( v1, v2, alpha2 ), 0, 255 );


            px += direction[ 0 ];
            py += direction[ 1 ];
            pz += direction[ 2 ];
#undef VAL
        }

    }

    void SIMD::warpLinePerspectiveBilinear4u8( uint8_t* _dst, const uint8_t* _src, size_t srcStride, size_t srcWidth, size_t srcHeight, const float* point, const float* direction, const size_t n ) const
    {
        const uint8_t* src = ( const uint8_t* ) _src;
        float px, py, pz;
        size_t i = n;
        Fixed one( ( int16_t ) 1 );
        uint32_t* dst = ( uint32_t* ) _dst;

        px = point[ 0 ];
        py = point[ 1 ];
        pz = point[ 2 ];

        while( i-- )
        {
            float fx, fy;

            fx = px / pz;
            fy = py / pz;

            uint32_t alpha1 = ( uint32_t ) Math::clamp<int32_t>( ( fx + 1 - ( float ) ( int )( fx + 1 ) ) * 0x100, 0x0, 0x100 );
            uint32_t alpha2 = ( uint32_t ) Math::clamp<int32_t>( ( fy + 1 - ( float ) ( int )( fy + 1 ) ) * 0x100, 0x0, 0x100 );

#define VAL( fx, fy ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( uint32_t* ) ( src + srcStride * ( fy ) + sizeof( uint32_t ) * ( fx ) ) ) : *dst

            int lx = -1 + ( int )( fx + 1 );
            int ly = -1 + ( int )( fy + 1 );
            uint32_t v1 = _mix4U8( VAL( lx, ly ), VAL( 1 + lx, ly  ), alpha1 );
            uint32_t v2 = _mix4U8( VAL( lx, 1 + ly ), VAL( 1 + lx, 1 + ly  ), alpha1 );
            *dst++ = _mix4U8( v1, v2, alpha2 );

            px += direction[ 0 ];
            py += direction[ 1 ];
            pz += direction[ 2 ];
#undef VAL
        }

    }

    void SIMD::warpBilinear1f( float* dst, const float* coords, const float* _src, size_t srcStride, size_t srcWidth, size_t srcHeight, float fillcolor, size_t n ) const
    {
        const uint8_t* src = ( const uint8_t* ) _src;
        int endx = ( ( int ) srcWidth ) - 1;
        int endy = ( ( int ) srcHeight ) - 1;

        while( n-- )
        {
            float fx, fy;

            fx = *coords++;
            fy = *coords++;
            int lx = _floor( fx );
            int ly = _floor( fy );

            if( lx >= 0 && lx < endx && ly >= 0 && ly < endy ) {
                float alpha1 = fx - ( float ) lx;
                float alpha2 = fy - ( float ) ly;
                float v1, v2, a, b;
                float* ptr = ( float* ) ( src + srcStride * ly + sizeof( float ) * lx );
                a = *ptr;
                b = *( ptr + 1 );
                v1 = Math::mix( a, b, alpha1 );
                ptr = ( float* ) ( ( ( uint8_t* ) ptr ) + srcStride );
                a = *ptr;
                b = *( ptr + 1 );
                v2 = Math::mix( a, b, alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
            } else if( lx >= -1 && lx < ( int ) srcWidth && ly >= -1 && ly < ( int ) srcHeight ) {
                float alpha1 = fx - ( float ) lx;
                float alpha2 = fy - ( float ) ly;
#define VAL( fx, fy ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( float* ) ( src + srcStride * ( fy ) + sizeof( float ) * ( fx ) ) ) : fillcolor
                float v1, v2, a, b;
                a = VAL( lx, ly );
                b = VAL( lx + 1, ly );
                v1 = Math::mix( a, b, alpha1 );
                a = VAL( lx, ly + 1 );
                b = VAL( lx + 1, ly + 1 );
                v2 = Math::mix( a, b, alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
#undef VAL
            } else
                *dst++ = fillcolor;
        }

    }

    void SIMD::warpBilinear4f( float* dst, const float* coords, const float* _src, size_t srcStride, size_t srcWidth, size_t srcHeight, const float* fillcolor, size_t n ) const
    {
        const uint8_t* src = ( const uint8_t* ) _src;
        int endx = ( ( int ) srcWidth ) - 1;
        int endy = ( ( int ) srcHeight ) - 1;


        while( n-- )
        {
            float fx, fy;

            fx = *coords++;
            fy = *coords++;

            int lx = _floor( fx );
            int ly = _floor( fy );

            if( lx >= 0 && lx < endx && ly >= 0 && ly < endy ) {
                float alpha1 = fx - ( float ) lx;
                float alpha2 = fy - ( float ) ly;
                float v1, v2;
                float* ptr1 = ( float* ) ( src + srcStride * ( ly ) + sizeof( float ) * lx * 4 );
                float* ptr2 = ( float* ) ( src + srcStride * ( ly + 1 ) + sizeof( float ) * lx * 4 );
                v1 = Math::mix( *ptr1, *( ptr1 + 4 ), alpha1 );
                v2 = Math::mix( *ptr2, *( ptr2 + 4 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
                ptr1++; ptr2++;
                v1 = Math::mix( *ptr1, *( ptr1 + 4 ), alpha1 );
                v2 = Math::mix( *ptr2, *( ptr2 + 4 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
                ptr1++; ptr2++;
                v1 = Math::mix( *ptr1, *( ptr1 + 4 ), alpha1 );
                v2 = Math::mix( *ptr2, *( ptr2 + 4 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
                ptr1++; ptr2++;
                v1 = Math::mix( *ptr1, *( ptr1 + 4 ), alpha1 );
                v2 = Math::mix( *ptr2, *( ptr2 + 4 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
                ptr1++; ptr2++;
            } else if( lx >= -1 && lx < ( int ) srcWidth && ly >= -1 && ly < ( int ) srcHeight ) {
                float alpha1 = fx - ( float ) lx;
                float alpha2 = fy - ( float ) ly;
#define VAL( fx, fy, offset ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( float* ) ( src + srcStride * ( fy ) + sizeof( float ) * ( ( fx ) * 4 + offset ) ) ) : fillcolor[ offset ]
                float v1, v2;
                v1 = Math::mix( VAL( lx, ly, 0 ), VAL( 1 + lx, ly, 0 ), alpha1 );
                v2 = Math::mix( VAL( lx, 1 + ly, 0 ), VAL( 1 + lx, 1 + ly, 0 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
                v1 = Math::mix( VAL( lx, ly, 1 ), VAL( 1 + lx, ly, 1 ), alpha1 );
                v2 = Math::mix( VAL( lx, 1 + ly, 1 ), VAL( 1 + lx, 1 + ly, 1 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
                v1 = Math::mix( VAL( lx, ly, 2 ), VAL( 1 + lx, ly, 2 ), alpha1 );
                v2 = Math::mix( VAL( lx, 1 + ly, 2 ), VAL( 1 + lx, 1 + ly, 2 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
                v1 = Math::mix( VAL( lx, ly, 3 ), VAL( 1 + lx, ly, 3 ), alpha1 );
                v2 = Math::mix( VAL( lx, 1 + ly, 3 ), VAL( 1 + lx, 1 + ly, 3 ), alpha1 );
                *dst++ = Math::mix( v1, v2, alpha2 );
#undef VAL
            } else {
                *dst++ = fillcolor[ 0 ];
                *dst++ = fillcolor[ 1 ];
                *dst++ = fillcolor[ 2 ];
                *dst++ = fillcolor[ 3 ];
            }

        }

    }

    void SIMD::warpBilinear1u8( uint8_t* dst, const float* coords, const uint8_t* src, size_t srcStride, size_t srcWidth, size_t srcHeight, uint8_t fill, size_t n ) const
    {
        int endx = ( ( int ) srcWidth ) - 1;
        int endy = ( ( int ) srcHeight ) - 1;

        while( n-- )
        {
            int fx = ( int ) ( *coords++ * 0x10000 );
            int fy = ( int ) ( *coords++ * 0x10000 );

            int lx =  fx >> 16;
            int ly =  fy >> 16;

            if( ( size_t ) lx < ( size_t ) endx && ( size_t ) ly < ( size_t ) endy ) {
                int32_t ax = fx & 0xffff;
                int32_t ay = fy & 0xffff;

                uint8_t* ptr = ( uint8_t* ) ( src + srcStride * ly + sizeof( uint8_t ) * lx );
                int32_t g0, g1, g2, g3;
                g0 = *ptr;
                g1 = *( ptr + 1 );
                ptr += srcStride;
                g2 = *ptr;
                g3 = *( ptr + 1 );

                int32_t v1 =  g0 + ( ( ( g1 - g0 ) * ax ) >> 16 );
                int32_t v2 =  g2 + ( ( ( g3 - g2 ) * ax ) >> 16 );
                *dst++ =  v1 + ( ( ( v2 - v1 ) * ay ) >> 16 );
            } else if( lx >= -1 && lx < ( int ) srcWidth && ly >= -1 && ly < ( int ) srcHeight ) {
                int32_t ax = fx & 0xffff;
                int32_t ay = fy & 0xffff;

#define VAL( fx, fy ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( uint8_t* ) ( src + srcStride * ( fy ) + sizeof( uint8_t ) * ( fx ) ) ) : fill
                int32_t a = VAL( lx, ly );
                int32_t b = VAL( lx + 1, ly );
                int32_t v1 =  a + ( ( ( b - a ) * ax ) >> 16 );
                a = VAL( lx, ly + 1 );
                b = VAL( lx + 1, ly + 1 );
                int32_t v2 =  a + ( ( ( b - a ) * ax ) >> 16 );
                *dst++ =  v1 + ( ( ( v2 - v1 ) * ay ) >> 16 );
#undef VAL
            } else
                *dst++ = fill;

        }

    }

    void SIMD::warpBilinear4u8( uint8_t* _dst, const float* coords, const uint8_t* src, size_t srcStride, size_t srcWidth, size_t srcHeight, uint32_t fill, size_t n ) const
    {
        int endx = ( ( int ) srcWidth ) - 1;
        int endy = ( ( int ) srcHeight ) - 1;
        uint32_t* dst = ( uint32_t* ) _dst;

        while( n-- )
        {
            int fx = ( int )( *( coords + 0 ) * ( 1 << 8 ) );
            int fy = ( int )( *( coords + 1 ) * ( 1 << 8 ) );
            coords += 2;

            int lx =  fx >> 8;
            int ly =  fy >> 8;

            if( lx >= 0 && lx < endx && ly >= 0 && ly < endy ) {
                uint32_t alpha1 = fx & 0xff;
                uint32_t alpha2 = fy & 0xff;

                uint32_t* ptr = ( uint32_t* ) ( src + srcStride * ( ly ) + sizeof( uint32_t ) * lx );
                uint32_t a, b;
                a = *ptr;
                b = *( ptr + 1 );
                uint32_t v1 = _mix4U8( a, b, alpha1 );
                ptr = ( uint32_t* ) ( ( ( uint8_t* ) ptr ) + srcStride );
                a = *ptr;
                b = *( ptr + 1 );
                uint32_t v2 = _mix4U8( a, b, alpha1 );
                *dst++ = _mix4U8( v1, v2, alpha2 );
            } else if( lx >= -1 && lx < ( int ) srcWidth && ly >= -1 && ly < ( int ) srcHeight ) {
                uint32_t alpha1 = fx & 0xff;
                uint32_t alpha2 = fy & 0xff;

#define VAL( fx, fy ) ( ( fx ) >= 0 && ( fx ) < ( int ) srcWidth && ( fy ) >= 0 && ( fy ) < ( int ) srcHeight ) ? *( ( uint32_t* ) ( src + srcStride * ( fy ) + sizeof( uint32_t ) * ( fx ) ) ) : fill
                uint32_t a, b;
                a = VAL( lx, ly );
                b = VAL( lx + 1, ly );
                uint32_t v1 = _mix4U8( a, b, alpha1 );
                a = VAL( lx, ly + 1 );
                b = VAL( lx + 1, ly + 1 );
                uint32_t v2 = _mix4U8( a, b, alpha1 );
                *dst++ = _mix4U8( v1, v2, alpha2 );
#undef VAL
            } else
                *dst++ = fill;
        }

    }

	void SIMD::harrisScore1f( float* dst, const float* boxdx2, const float* boxdy2, const float* boxdxdy, float k, size_t width ) const
	{
		size_t x;

		for( x = 0; x < width; x++ ) {
			float a, b, c;
			a = *boxdx2++;
			b = *boxdy2++;
			c = *boxdxdy++;
			*dst++ = ( a * b - c * c ) - ( k * Math::sqr(a + b) );
		}
	}


    float SIMD::harrisResponse1u8( const uint8_t* _src, size_t srcStride, size_t w, size_t h, const float k ) const
    {
        const uint8_t* src = _src - ( h - 1 ) * srcStride - ( w - 1 );
        float Ix = 0;
        float Iy = 0;
        float a = 0, b = 0, c = 0;

        for( size_t y = 0, yend = 2 * ( w - 1 ) + 1; y < yend; y++ ) {
            const uint8_t* psrc = src;
            for( size_t x = 0, xend = 2 * ( h - 1 ) + 1; x < xend; x++ ) {
                Ix = 2.0f * ( ( float )*( psrc + 1 ) - ( float )*( psrc - 1 ) );
                Ix += ( ( float )*( psrc + 1 + srcStride ) - ( float )*( psrc - 1 + srcStride ) );
                Ix += ( ( float )*( psrc + 1 - srcStride ) - ( float )*( psrc - 1 - srcStride ) );

                Iy = 2.0f * ( ( float )*( psrc + srcStride ) - ( float )*( psrc - srcStride ) );
                Iy += ( ( float )*( psrc + srcStride + 1 ) - ( float )*( psrc - srcStride + 1 ) );
                Iy += ( ( float )*( psrc + srcStride - 1 ) - ( float )*( psrc - srcStride - 1 ) );

                a += Ix * Ix;
                b += Iy * Iy;
                c += Ix * Iy;
                psrc++;
            }
            src += srcStride;
        }

        return ( a * b - c * c ) - ( k * Math::sqr(a + b) );
    }


    float SIMD::harrisResponse1u8( float & xx, float & xy, float & yy, const uint8_t* _src, size_t srcStride, size_t w, size_t h, const float k ) const
    {
        const uint8_t* src = _src - ( h - 1 ) * srcStride - ( w - 1 );
        float Ix = 0;
        float Iy = 0;
        float a = 0, b = 0, c = 0;

        for( size_t y = 0, yend = 2 * ( w - 1 ) + 1; y < yend; y++ ) {
            const uint8_t* psrc = src;
            for( size_t x = 0, xend = 2 * ( h - 1 ) + 1; x < xend; x++ ) {
                Ix = 2.0f * ( ( float )*( psrc + 1 ) - ( float )*( psrc - 1 ) );
                Ix += ( ( float )*( psrc + 1 + srcStride ) - ( float )*( psrc - 1 + srcStride ) );
                Ix += ( ( float )*( psrc + 1 - srcStride ) - ( float )*( psrc - 1 - srcStride ) );

                Iy = 2.0f * ( ( float )*( psrc + srcStride ) - ( float )*( psrc - srcStride ) );
                Iy += ( ( float )*( psrc + srcStride + 1 ) - ( float )*( psrc - srcStride + 1 ) );
                Iy += ( ( float )*( psrc + srcStride - 1 ) - ( float )*( psrc - srcStride - 1 ) );

                a += Ix * Ix;
                b += Iy * Iy;
                c += Ix * Iy;
                psrc++;
            }
            src += srcStride;
        }
        xx = a; yy = b; xy = c;
        return ( a * b - c * c ) - ( k * Math::sqr(a + b) );
    }

    float SIMD::harrisResponseCircular1u8( float & xx, float & xy, float & yy, const uint8_t* _src, size_t srcStride, const float k ) const
    {
        const size_t w = 8;
        const size_t h = 8;
        const uint8_t* src = _src - ( h - 1 ) * srcStride - ( w - 1 );
        float Ix = 0;
        float Iy = 0;
        float a = 0, b = 0, c = 0, n = 0;
//		const float wght[ 9 ] = { 0.0048150f, 0.0287160f, 0.1028185f, 0.2210241f, 0.2852523f,
//								  0.2210241f, 0.1028185f, 0.0287160f, 0.0048150f };
//  const float wght[ 15 ] =  { 0.000436407426038f,   0.002216259780359f,   0.008765477469243f,   0.026999571389574f,
//   0.064768604754149f,   0.121003684000465f,   0.176059321357850f,   0.199501347644643f,
//   0.176059321357850f,   0.121003684000465f,   0.064768604754149f,   0.026999571389574f,
//   0.008765477469243f,   0.002216259780359f,   0.000436407426038f };


  const float wght[ 15 ] = { 0.001149079657613f,   0.004401460998178f,   0.013712394984760f,   0.034745575262543f,
   0.071606992455918f,   0.120027592615994f,   0.163635110039819f,   0.181443587970351f,
   0.163635110039819f,   0.120027592615994f,   0.071606992455918f,   0.034745575262543f,
   0.013712394984760f,   0.004401460998178f,   0.001149079657613f };
//		const float wght[ 31 ] = {
//   0.000088157939303,   0.000218192995285,   0.000507313913423,   0.001108075461036,
//   0.002273623221016,   0.004382523463181,   0.007935724797396,   0.013499122612070,
//   0.021571536512413,   0.032382711724327,   0.045666943155140,   0.060498870269667,
//   0.075292060547733,   0.088025336836466,   0.096676919418081,   0.099745774266927,
//   0.096676919418081,   0.088025336836466,   0.075292060547733,   0.060498870269667,
//   0.045666943155140,   0.032382711724327,   0.021571536512413,   0.013499122612070,
//   0.007935724797396,   0.004382523463181,   0.002273623221016,   0.001108075461036,
//   0.000507313913423,   0.000218192995285,   0.000088157939303,
//		};
        for( size_t y = 0, yend = 2 * ( w - 1 ) + 1; y < yend; y++ ) {
            const uint8_t* psrc = src;
            for( size_t x = 0, xend = 2 * ( h - 1 ) + 1; x < xend; x++ ) {
                Ix = 2.0f * ( ( float )*( psrc + 1 ) - ( float )*( psrc - 1 ) );
                Ix += ( ( float )*( psrc + 1 + srcStride ) - ( float )*( psrc - 1 + srcStride ) );
                Ix += ( ( float )*( psrc + 1 - srcStride ) - ( float )*( psrc - 1 - srcStride ) );

                Iy = 2.0f * ( ( float )*( psrc + srcStride ) - ( float )*( psrc - srcStride ) );
                Iy += ( ( float )*( psrc + srcStride + 1 ) - ( float )*( psrc - srcStride + 1 ) );
                Iy += ( ( float )*( psrc + srcStride - 1 ) - ( float )*( psrc - srcStride - 1 ) );

                float w = wght[ x ] * wght[ y ];
                //float xr = ( float ) x - 15.0f;
                //float yr = ( float ) y - 15.0f;
                //if( Math::sqrt( xr * xr + yr * yr ) <= 15.0f ) {
                    a += Ix * Ix * w;
                    b += Iy * Iy * w;
                    c += Ix * Iy * w;
                    n += w;
                //}
                psrc++;
            }
            src += srcStride;
        }
        //a -= mx * mx;
        //b -= my * my;
        //c -= mx * my;
        //a /= n;
        //b /= n;
        //c /= n;
        //mx /= n;
        //my /= n;
        xx = a; yy = b; xy = c;
        return ( a * b - c * c ) - ( k * Math::sqr(a + b) );
        //return ( a * b - c * c ) / ( a + b );
    }

#define BAYER_RGGB_R1( x ) ( ( x ) & 0xff )
#define BAYER_RGGB_R2( x ) ( ( ( x ) & 0xff0000 ) >> 16 )
#define BAYER_RGGB_EVEN_G1( x ) ( ( x ) & 0xff )
#define BAYER_RGGB_EVEN_G2( x ) ( ( ( x ) & 0xff0000 ) >> 16 )
#define BAYER_RGGB_ODD_G1( x ) ( ( ( x ) & 0xff00 ) >> 8 )
#define BAYER_RGGB_ODD_G2( x ) ( ( x ) >> 24 )
#define BAYER_RGGB_B1( x ) ( ( ( x ) & 0xff00 ) >> 8 )
#define BAYER_RGGB_B2( x ) ( ( x ) >> 24 )

#define BAYER_MIX2( x, y ) ( ( ( x ) + ( y ) ) >> 1 )
#define BAYER_MIX4( x, y, z, w  ) ( ( ( x ) + ( y ) + ( z ) + ( w ) ) >> 2 )

    void SIMD::debayer_ODD_RGGBu8_RGBAu8( uint32_t* dst, const uint32_t* src1, const uint32_t* src2, const uint32_t* src3, const size_t n ) const
    {
        uint32_t v;
        size_t i;

        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ); // RED
        v |= BAYER_RGGB_EVEN_G1( *src2 ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ) <<16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ); // RED
        v |= BAYER_RGGB_EVEN_G2( *src2 ) << 8; // GREEN
        v |=  BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX4( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ), BAYER_RGGB_R1( *( src1 + 1  ) ), BAYER_RGGB_R1( *( src3 + 1 ) ) ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G1( *( src2 + 1 ) ) ) << 8; // GREEN
        v |= BAYER_RGGB_B2( *src2 ) << 16; // BLUE
        *dst++ = v;
        src1++;
        src2++;
        src3++;
        i = n - 2;
        while( i-- ) {
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ); // RED
            v |= BAYER_RGGB_EVEN_G1( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *( src2 - 1 ) ) ) <<16; // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ); // RED
            v |= BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
            v |= BAYER_RGGB_B1( *src2 ) << 16; // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ); // RED
            v |= BAYER_RGGB_EVEN_G2( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ) << 16; // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX4( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ), BAYER_RGGB_R1( *( src1 + 1  ) ), BAYER_RGGB_R1( *( src3 + 1 ) ) ); // RED
            v |= BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G1( *( src2 + 1 ) ) ) << 8; // GREEN
            v |= BAYER_RGGB_B2( *src2 ) << 16; // BLUE
            *dst++ = v;
            src1++;
            src2++;
            src3++;
        }
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ); // RED
        v |= BAYER_RGGB_EVEN_G1( *src2 ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ) <<16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ); // RED
        v |= BAYER_RGGB_EVEN_G2( *src2 ) << 8; // GREEN
        v |=  BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_RGGB_B2( *src2 ) << 16; // BLUE
        *dst++ = v;
    }

    void SIMD::debayer_EVEN_RGGBu8_RGBAu8( uint32_t* dst, const uint32_t* src1, const uint32_t* src2, const uint32_t* src3, const size_t n ) const
    {
        uint32_t v;
        size_t i;

        v = 0xff000000;
        v |= BAYER_RGGB_R1( *src2 ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G1( *src2 ) ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) <<16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ); // RED
        v |= BAYER_RGGB_ODD_G1( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_RGGB_R2( *src2 ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src2 ), BAYER_RGGB_R1( *( src2 + 1 ) ) ); // RED
        v |= BAYER_RGGB_ODD_G2( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ) << 16; // BLUE
        *dst++ = v;
        src1++;
        src2++;
        src3++;
        i = n - 2;
        while( i-- ) {
            v = 0xff000000;
            v |= BAYER_RGGB_R1( *src2 ); // RED
            v |= BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *( src2 - 1 ) ) ) << 8; // GREEN
            v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *( src1 - 1 ) ), BAYER_RGGB_B2( *( src3 - 1 ) ) ) <<16; // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ); // RED
            v |= BAYER_RGGB_ODD_G1( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) << 16; // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_RGGB_R2( *src2 ); // RED
            v |= BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) << 8; // GREEN
            v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ) << 16; // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R2( *src2 ), BAYER_RGGB_R1( *( src2 + 1 ) ) ); // RED
            v |= BAYER_RGGB_ODD_G2( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ) << 16; // BLUE
            *dst++ = v;
            src1++;
            src2++;
            src3++;
        }
        v = 0xff000000;
        v |= BAYER_RGGB_R1( *src2 ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *( src2 - 1 ) ) ) << 8; // GREEN
        v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *( src1 - 1 ) ), BAYER_RGGB_B2( *( src3 - 1 ) ) ) <<16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ); // RED
        v |= BAYER_RGGB_ODD_G1( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_RGGB_R2( *src2 ); // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ) << 16; // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_RGGB_R2( *src2 ); // RED
        v |= BAYER_RGGB_ODD_G2( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ) << 16; // BLUE
        *dst++ = v;
    }

    void SIMD::debayer_ODD_RGGBu8_BGRAu8( uint32_t* dst, const uint32_t* src1, const uint32_t* src2, const uint32_t* src3, const size_t n ) const
    {
        uint32_t v;
        size_t i;

        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ) << 16; // RED
        v |= BAYER_RGGB_EVEN_G1( *src2 ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) << 16; // RED
        v |= BAYER_RGGB_EVEN_G2( *src2 ) << 8; // GREEN
        v |=  BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX4( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ), BAYER_RGGB_R1( *( src1 + 1  ) ), BAYER_RGGB_R1( *( src3 + 1 ) ) ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G1( *( src2 + 1 ) ) ) << 8; // GREEN
        v |= BAYER_RGGB_B2( *src2 ); // BLUE
        *dst++ = v;
        src1++;
        src2++;
        src3++;
        i = n - 2;
        while( i-- ) {
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ) << 16; // RED
            v |= BAYER_RGGB_EVEN_G1( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *( src2 - 1 ) ) ); // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ) << 16; // RED
            v |= BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
            v |= BAYER_RGGB_B1( *src2 ); // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) << 16; // RED
            v |= BAYER_RGGB_EVEN_G2( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ); // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX4( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ), BAYER_RGGB_R1( *( src1 + 1  ) ), BAYER_RGGB_R1( *( src3 + 1 ) ) ) << 16; // RED
            v |= BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G1( *( src2 + 1 ) ) ) << 8; // GREEN
            v |= BAYER_RGGB_B2( *src2 ); // BLUE
            *dst++ = v;
            src1++;
            src2++;
            src3++;
        }
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ) << 16; // RED
        v |= BAYER_RGGB_EVEN_G1( *src2 ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_RGGB_B1( *src2 ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) << 16; // RED
        v |= BAYER_RGGB_EVEN_G2( *src2 ) << 8; // GREEN
        v |=  BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_RGGB_B2( *src2 ); // BLUE
        *dst++ = v;
    }

    void SIMD::debayer_EVEN_RGGBu8_BGRAu8( uint32_t* dst, const uint32_t* src1, const uint32_t* src2, const uint32_t* src3, const size_t n ) const
    {
        uint32_t v;
        size_t i;

        v = 0xff000000;
        v |= BAYER_RGGB_R1( *src2 ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G1( *src2 ) ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ) << 16; // RED
        v |= BAYER_RGGB_ODD_G1( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_RGGB_R2( *src2 ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R2( *src2 ), BAYER_RGGB_R1( *( src2 + 1 ) ) ) << 16; // RED
        v |= BAYER_RGGB_ODD_G2( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ); // BLUE
        *dst++ = v;
        src1++;
        src2++;
        src3++;
        i = n - 2;
        while( i-- ) {
            v = 0xff000000;
            v |= BAYER_RGGB_R1( *src2 ) << 16; // RED
            v |= BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *( src2 - 1 ) ) ) << 8; // GREEN
            v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *( src1 - 1 ) ), BAYER_RGGB_B2( *( src3 - 1 ) ) ); // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ) << 16; // RED
            v |= BAYER_RGGB_ODD_G1( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ); // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_RGGB_R2( *src2 ) << 16; // RED
            v |= BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) << 8; // GREEN
            v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ); // BLUE
            *dst++ = v;
            v = 0xff000000;
            v |= BAYER_MIX2( BAYER_RGGB_R2( *src2 ), BAYER_RGGB_R1( *( src2 + 1 ) ) ) << 16; // RED
            v |= BAYER_RGGB_ODD_G2( *src2 ) << 8; // GREEN
            v |= BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ); // BLUE
            *dst++ = v;
            src1++;
            src2++;
            src3++;
        }
        v = 0xff000000;
        v |= BAYER_RGGB_R1( *src2 ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *( src2 - 1 ) ) ) << 8; // GREEN
        v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *( src1 - 1 ) ), BAYER_RGGB_B2( *( src3 - 1 ) ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ) << 16; // RED
        v |= BAYER_RGGB_ODD_G1( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_RGGB_R2( *src2 ) << 16; // RED
        v |= BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) << 8; // GREEN
        v |= BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ); // BLUE
        *dst++ = v;
        v = 0xff000000;
        v |= BAYER_RGGB_R2( *src2 ) << 16; // RED
        v |= BAYER_RGGB_ODD_G2( *src2 ) << 8; // GREEN
        v |= BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ); // BLUE
        *dst++ = v;
    }

#define MULFIXED( a, b ) ( ( ( a ) * ( b ) + 0x80 ) >> 8 )
#define R2LUM( x ) ( MULFIXED( x, 0x36 ) )
#define G2LUM( x ) ( MULFIXED( x, 0xB7 ) )
#define B2LUM( x ) ( MULFIXED( x, 0x12 ) )

    void SIMD::debayer_ODD_RGGBu8_GRAYu8( uint32_t* dst, const uint32_t* src1, const uint32_t* src2, const uint32_t* src3, const size_t n ) const
    {
        uint32_t v, t;
        size_t i;

        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ) ); // RED
        t += G2LUM( BAYER_RGGB_EVEN_G1( *src2 ) ); // GREEN
        t += B2LUM( BAYER_RGGB_B1( *src2 ) ); // BLUE
        v = t;
        t  = R2LUM( BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) ); // GREEN
        t += B2LUM( BAYER_RGGB_B1( *src2 ) ); // BLUE
        v |= t << 8;
        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) ); // RED
        t += G2LUM( BAYER_RGGB_EVEN_G2( *src2 ) ); // GREEN
        t += B2LUM( BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ) ); // BLUE
        v |= t << 16;
        t  = R2LUM( BAYER_MIX4( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ), BAYER_RGGB_R1( *( src1 + 1  ) ), BAYER_RGGB_R1( *( src3 + 1 ) ) ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G1( *( src2 + 1 ) ) ) ); // GREEN
        t += B2LUM( BAYER_RGGB_B2( *src2 ) ); // BLUE
        v |= t << 24;
        *dst++ = v;
        src1++;
        src2++;
        src3++;
        i = n - 2;
        while( i-- ) {
            t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ) ); // RED
            t += G2LUM( BAYER_RGGB_EVEN_G1( *src2 ) ); // GREEN
            t += B2LUM( BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *( src2 - 1 ) ) ) ); // BLUE
            v = t;
            t  = R2LUM( BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ) ); // RED
            t += G2LUM( BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) ); // GREEN
            t += B2LUM( BAYER_RGGB_B1( *src2 ) ); // BLUE
            v |= t << 8;
            t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) ); // RED
            t += G2LUM( BAYER_RGGB_EVEN_G2( *src2 ) ); // GREEN
            t += B2LUM( BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ) ); // BLUE
            v |= t << 16;
            t  = R2LUM( BAYER_MIX4( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ), BAYER_RGGB_R1( *( src1 + 1  ) ), BAYER_RGGB_R1( *( src3 + 1 ) ) ) ); // RED
            t += G2LUM( BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G1( *( src2 + 1 ) ) ) ); // GREEN
            t += B2LUM( BAYER_RGGB_B2( *src2 ) ); // BLUE
            v |= t << 24;
            *dst++ = v;
            src1++;
            src2++;
            src3++;
        }
        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R1( *src3 ) ) ); // RED
        t += G2LUM( BAYER_RGGB_EVEN_G1( *src2 ) ); // GREEN
        t += B2LUM( BAYER_RGGB_B1( *src2 ) ); // BLUE
        v = t;
        t  = R2LUM( BAYER_MIX4( BAYER_RGGB_R1( *src1 ), BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R1( *src3 ), BAYER_RGGB_R2( *src3 ) ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_ODD_G1( *src1 ), BAYER_RGGB_ODD_G1( *src3 ), BAYER_RGGB_EVEN_G1( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) ); // GREEN
        t += B2LUM( BAYER_RGGB_B1( *src2 ) ); // BLUE
        v |= t << 8;
        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) ); // RED
        t += G2LUM( BAYER_RGGB_EVEN_G2( *src2 ) ); // GREEN
        t += B2LUM(  BAYER_MIX2( BAYER_RGGB_B1( *src2 ), BAYER_RGGB_B2( *src2 ) ) ); // BLUE
        v |= t << 16;
        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R2( *src1 ), BAYER_RGGB_R2( *src3 ) ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_ODD_G2( *src1 ), BAYER_RGGB_ODD_G2( *src3 ), BAYER_RGGB_EVEN_G2( *src2 ), BAYER_RGGB_EVEN_G2( *src2 ) ) ); // GREEN
        t += B2LUM( BAYER_RGGB_B2( *src2 ) ); // BLUE
        v |= t << 24;
        *dst++ = v;
    }

    void SIMD::debayer_EVEN_RGGBu8_GRAYu8( uint32_t* dst, const uint32_t* src1, const uint32_t* src2, const uint32_t* src3, const size_t n ) const
    {
        uint32_t v, t;
        size_t i;

        t  = R2LUM( BAYER_RGGB_R1( *src2 ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G1( *src2 ) ) ); // GREEN
        t += B2LUM( BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) ); // BLUE
        v = t;
        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ) ); // RED
        t += G2LUM( BAYER_RGGB_ODD_G1( *src2 ) ); // GREEN
        t += B2LUM( BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) ); // BLUE
        v |= t << 8;
        t  = R2LUM( BAYER_RGGB_R2( *src2 ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) ); // GREEN
        t += B2LUM( BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ) ); // BLUE
        v |= t << 16;
        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R2( *src2 ), BAYER_RGGB_R1( *( src2 + 1 ) ) ) ); // RED
        t += G2LUM( BAYER_RGGB_ODD_G2( *src2 ) ); // GREEN
        t += B2LUM( BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ) ); // BLUE
        v |= t << 24;
        *dst++ = v;
        src1++;
        src2++;
        src3++;
        i = n - 2;
        while( i-- ) {
            t  = R2LUM( BAYER_RGGB_R1( *src2 ) ); // RED
            t += G2LUM( BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *( src2 - 1 ) ) ) ); // GREEN
            t += B2LUM( BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *( src1 - 1 ) ), BAYER_RGGB_B2( *( src3 - 1 ) ) ) ); // BLUE
            v = t;
            t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ) ); // RED
            t += G2LUM( BAYER_RGGB_ODD_G1( *src2 ) ); // GREEN
            t += B2LUM( BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) ); // BLUE
            v |= t << 8;
            t  = R2LUM( BAYER_RGGB_R2( *src2 ) ); // RED
            t += G2LUM( BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) ); // GREEN
            t += B2LUM( BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ) ); // BLUE
            v |= t << 16;
            t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R2( *src2 ), BAYER_RGGB_R1( *( src2 + 1 ) ) ) ); // RED
            t += G2LUM( BAYER_RGGB_ODD_G2( *src2 ) ); // GREEN
            t += B2LUM( BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ) ); // BLUE
            v |= t << 24;
            *dst++ = v;
            src1++;
            src2++;
            src3++;
        }
        t  = R2LUM( BAYER_RGGB_R1( *src2 ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_EVEN_G1( *src1 ), BAYER_RGGB_EVEN_G1( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *( src2 - 1 ) ) ) ); // GREEN
        t += B2LUM( BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *( src1 - 1 ) ), BAYER_RGGB_B2( *( src3 - 1 ) ) ) ); // BLUE
        v = t;
        t  = R2LUM( BAYER_MIX2( BAYER_RGGB_R1( *src2 ), BAYER_RGGB_R2( *src2 ) ) ); // RED
        t += G2LUM( BAYER_RGGB_ODD_G1( *src2 ) ); // GREEN
        t += B2LUM( BAYER_MIX2( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B1( *src3 ) ) ); // BLUE
        v |= t << 8;
        t  = R2LUM( BAYER_RGGB_R2( *src2 ) ); // RED
        t += G2LUM( BAYER_MIX4( BAYER_RGGB_EVEN_G2( *src1 ), BAYER_RGGB_EVEN_G2( *src3 ), BAYER_RGGB_ODD_G1( *src2 ), BAYER_RGGB_ODD_G2( *src2 ) ) ); // GREEN
        t += B2LUM( BAYER_MIX4( BAYER_RGGB_B1( *src1 ), BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B1( *src3 ), BAYER_RGGB_B2( *src3 ) ) ); // BLUE
        v |= t << 16;
        t  = R2LUM( BAYER_RGGB_R2( *src2 ) ); // RED
        t += G2LUM( BAYER_RGGB_ODD_G2( *src2 ) ); // GREEN
        t += B2LUM( BAYER_MIX2( BAYER_RGGB_B2( *src1 ), BAYER_RGGB_B2( *src3 ) ) ); // BLUE
        v |= t << 24;
        *dst++ = v;
    }

#define HQPTR(x,off) ( ( int ) *((x)+off) )

#define BAYER_HQ_G_AT_R( p1, p2, p3, p4, p5 ) ( ( ( ( HQPTR(p3,-1) + HQPTR(p3,1) + HQPTR(p2,0) + HQPTR(p4,0) ) << 1 ) \
                                                 + ( HQPTR(p3,0) << 2 ) - HQPTR(p1,0) - HQPTR(p5,0) - HQPTR(p3,-2) - HQPTR(p3,2) ) >> 3 )

#define BAYER_HQ_G_AT_B( p1, p2, p3, p4, p5 ) BAYER_HQ_G_AT_R( p1, p2, p3, p4, p5 )


#define BAYER_HQ_R_AT_G_EVEN( p1, p2, p3, p4, p5 ) ( ( ( ( HQPTR(p3,-1) + HQPTR(p3, 1) ) << 2 ) + ( HQPTR(p3,0) << 2 ) + HQPTR(p3,0) \
													  - HQPTR(p2,-1) - HQPTR(p2,+1) - HQPTR(p4,-1) - HQPTR(p4,1) - HQPTR(p3,-2) - HQPTR(p3,+2) + \
													( ( HQPTR(p1,0) + HQPTR(p5,0) ) >> 1 ) ) >> 3 )

#define BAYER_HQ_B_AT_G_EVEN( p1, p2, p3, p4, p5 ) ( ( ( ( HQPTR(p2,0) + HQPTR(p4, 0) ) << 2 ) + ( HQPTR(p3,0) << 2 ) + HQPTR(p3,0) \
													  - HQPTR(p2,-1) - HQPTR(p2,+1) - HQPTR(p4,-1) - HQPTR(p4,1) - HQPTR(p1,0) - HQPTR(p5,0) + \
													( ( HQPTR(p3,-2) + HQPTR(p3,+2) ) >> 1 ) ) >> 3 )


#define BAYER_HQ_B_AT_R_EVEN( p1, p2, p3, p4, p5 ) ( ( ( ( HQPTR(p2,-1) + HQPTR(p2, 1) + HQPTR(p4,-1) + HQPTR(p4,1) ) << 1 ) + ( ( HQPTR(p3,0) << 2 ) + ( HQPTR(p3,0) << 1 ) ) \
													- ( HQPTR(p3,-2) + HQPTR(p3,+2) + HQPTR(p1,0) + HQPTR(p5,0) ) \
													- ( ( HQPTR(p3,-2) + HQPTR(p3,+2) + HQPTR(p1,0) + HQPTR(p5,0) ) >> 1  ) ) >> 3 )

#define BAYER_HQ_R_AT_G_ODD( p1, p2, p3, p4, p5 ) BAYER_HQ_B_AT_G_EVEN( p1, p2, p3, p4, p5 )

#define BAYER_HQ_B_AT_G_ODD( p1, p2, p3, p4, p5 ) BAYER_HQ_R_AT_G_EVEN( p1, p2, p3, p4, p5 )

#define BAYER_HQ_R_AT_B_ODD( p1, p2, p3, p4, p5 ) BAYER_HQ_B_AT_R_EVEN( p1, p2, p3, p4, p5 )

	void SIMD::debayerhq_EVEN_RGGBu8_RGBAu8( uint32_t* dst, const uint32_t* _src1, const uint32_t* _src2, const uint32_t* _src3,
											 const uint32_t* _src4, const uint32_t* _src5, size_t n ) const
	{
		uint32_t v;
		const uint8_t* src1 = ( const uint8_t* ) _src1;
		const uint8_t* src2 = ( const uint8_t* ) _src2;
		const uint8_t* src3 = ( const uint8_t* ) _src3;
		const uint8_t* src4 = ( const uint8_t* ) _src4;
		const uint8_t* src5 = ( const uint8_t* ) _src5;

		v = 0xff000000;
		v |= *src3; // RED
		v |= BAYER_MIX4( HQPTR(src3,1), HQPTR(src3,1), HQPTR(src2,0), HQPTR(src4,0) ) << 8; // GREEN
		v |= BAYER_MIX2( HQPTR(src2,1), HQPTR(src4,1) ) << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;

		v = 0xff000000;
		v |= BAYER_MIX2( HQPTR(src3,1), HQPTR(src3,-1) ); // RED
		v |= *src3 << 8; // GREEN
		v |= BAYER_MIX2( HQPTR(src2,0), HQPTR(src4,0) ) << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;

		size_t i = ( n - 4 ) >> 1;
		while( i-- ) {
			v = 0xff000000;
			v |= *src3; // RED
			v |= Math::clamp( BAYER_HQ_G_AT_R( src1, src2, src3, src4, src5 ), 0x0, 0xff ) << 8; // GREEN
			v |= Math::clamp( BAYER_HQ_B_AT_R_EVEN( src1, src2, src3, src4, src5 ), 0x0, 0xff ) << 16; // BLUE
			*dst++ = v;
			src1++;
			src2++;
			src3++;
			src4++;
			src5++;

			v = 0xff000000;
			v |= Math::clamp( BAYER_HQ_R_AT_G_EVEN( src1, src2, src3, src4, src5 ), 0x0, 0xff ); // RED
			v |= ( *src3 ) << 8; // GREEN
			v |= Math::clamp( BAYER_HQ_B_AT_G_EVEN( src1, src2, src3, src4, src5 ), 0x0, 0xff ) << 16; // BLUE
			*dst++ = v;
			src1++;
			src2++;
			src3++;
			src4++;
			src5++;
		}

		v = 0xff000000;
		v |= *src3; // RED
		v |= BAYER_MIX4( HQPTR(src3,-1), HQPTR(src3,1), HQPTR(src2,0), HQPTR(src4,0) ) << 8; // GREEN
		v |= BAYER_MIX4( HQPTR(src2,-1), HQPTR(src4,-1), HQPTR(src2,1), HQPTR(src4,1) ) << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;

		v = 0xff000000;
		v |= *( src3 - 1 ); // RED
		v |= *src3 << 8; // GREEN
		v |= BAYER_MIX2( HQPTR(src2,0), HQPTR(src4,0) ) << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;
	}

	void SIMD::debayerhq_ODD_RGGBu8_RGBAu8( uint32_t* dst, const uint32_t* _src1, const uint32_t* _src2, const uint32_t* _src3,
											 const uint32_t* _src4, const uint32_t* _src5, size_t n ) const
	{
		uint32_t v;
		const uint8_t* src1 = ( const uint8_t* ) _src1;
		const uint8_t* src2 = ( const uint8_t* ) _src2;
		const uint8_t* src3 = ( const uint8_t* ) _src3;
		const uint8_t* src4 = ( const uint8_t* ) _src4;
		const uint8_t* src5 = ( const uint8_t* ) _src5;

		v = 0xff000000;
		v |= BAYER_MIX2( HQPTR(src2,0), HQPTR(src4,0) ); // RED
		v |= *src3 << 8; // GREEN
		v |= *(src3+1) << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;

		v = 0xff000000;
		v |= BAYER_MIX4( HQPTR(src2,-1), HQPTR(src4,-1), HQPTR(src2,1), HQPTR(src4,1) ); // RED
		v |= BAYER_MIX4( HQPTR(src2,0), HQPTR(src4,0), HQPTR(src3,-1), HQPTR(src3,1) ) << 8; // GREEN
		v |= *src3 << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;

		size_t i = ( n - 4 ) >> 1;
		while( i-- ) {
			v = 0xff000000;
			v |= Math::clamp( BAYER_HQ_R_AT_G_ODD( src1, src2, src3, src4, src5 ), 0x0, 0xff ); // RED
			v |= *src3 << 8; // GREEN
			v |= Math::clamp( BAYER_HQ_B_AT_G_ODD( src1, src2, src3, src4, src5 ), 0x0, 0xff ) << 16; // BLUE
			*dst++ = v;
			src1++;
			src2++;
			src3++;
			src4++;
			src5++;

			v = 0xff000000;
			v |= Math::clamp( BAYER_HQ_R_AT_B_ODD( src1, src2, src3, src4, src5 ), 0x0, 0xff ); // RED
			v |= Math::clamp( BAYER_HQ_G_AT_B( src1, src2, src3, src4, src5 ), 0x0, 0xff ) << 8; // GREEN
			v |= *src3 << 16; // BLUE
			*dst++ = v;
			src1++;
			src2++;
			src3++;
			src4++;
			src5++;
		}

		v = 0xff000000;
		v |= BAYER_MIX2( HQPTR(src2,0), HQPTR(src4,0) ); // RED
		v |= *src3 << 8; // GREEN
		v |= BAYER_MIX2( HQPTR(src3,-1), HQPTR(src3,1) ) << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;

		v = 0xff000000;
		v |= BAYER_MIX2( HQPTR(src2,-1), HQPTR(src4,-1) ); // RED
		v |= BAYER_MIX4( HQPTR(src2,0), HQPTR(src4,0), HQPTR(src3,-1), HQPTR(src3,-1) ) << 8; // GREEN
		v |= *src3 << 16; // BLUE
		*dst++ = v;
		src1++;
		src2++;
		src3++;
		src4++;
		src5++;
	}

#define _IIR_INITIAL4( c )\
        l0[ c ] = n[ 0 ] * x0[ c ] + n[ 1 ] * x0[ c ] + n[ 2 ] * x0[ c ] + n[ 3 ] * x0[ c ]\
            - b * ( d[ 0 ] * x0[ c ] + d[ 1 ] * x0[ c ] + d[ 2 ] * x0[ c ] + d[ 3 ] * x0[ c ] );\
        l1[ c ] = n[ 0 ] * x1[ c ] + n[ 1 ] * x0[ c ] + n[ 2 ] * x0[ c ] + n[ 3 ] * x0[ c ]\
            - l0[ c ] * d[ 0 ] - b * ( d[ 1 ] * x0[ c ] + d[ 2 ] * x0[ c ] + d[ 3 ] * x0[ c ] );\
        l2[ c ] = n[ 0 ] * x2[ c ] + n[ 1 ] * x1[ c ] + n[ 2 ] * x0[ c ] + n[ 3 ] * x0[ c ]\
            - l1[ c ] * d[ 0 ] - l0[ c ] * d[ 1 ] - b * (  d[ 2 ] * x0[ c ] + d[ 3 ] * x0[ c ] );\
        l3[ c ] = n[ 0 ] * x3[ c ] + n[ 1 ] * x2[ c  ] + n[ 2 ] * x1[ c ] + n[ 3 ] * x0[ c ]\
            - l2[ c ] * d[ 0 ] - l1[ c ] * d[ 1 ] - l0[ c ] * d[ 2 ] - d[ 3 ] * x0[ c ] * b;

#define _IIR_CURRENT( c ) \
        l3[ channels + c ] = n[ 0 ] * x3[ c ] + n[ 1 ] * x2[ c ] + n[ 2 ] * x1[ c ] + n[ 3 ] * x0[ c ]\
                            - d[ 0 ] * l3[ c ] - d[ 1 ] * l2[ c ] - d[ 2 ] * l1[ c ] - d[ 3 ] * l0[ c ];

#define _IIR_CURRENT_BWD( c ) \
        tmpVal[ c ] = n[ 0 ] * x3[ c ] + n[ 1 ] * x2[ c ] + n[ 2 ] * x1[ c ] + n[ 3 ] * x0[ c ]\
                            - d[ 0 ] * l3[ c ] - d[ 1 ] * l2[ c ] - d[ 2 ] * l1[ c ] - d[ 3 ] * l0[ c ];\
        y3[ c ] = Math::clamp( ( t3[ c ] + tmpVal[ c ] ).round(), 0, 255 );

    void SIMD::IIR4FwdHorizontal4Fx( Fixed* dst, const uint8_t * src, size_t w,
                                     const Fixed * n, const Fixed * d, const Fixed & b ) const
    {
        static const uint8_t channels = 4;
        const uint8_t * x0;
        const uint8_t * x1;
        const uint8_t * x2;
        const uint8_t * x3;

        x0 = src; x1 = x0 + channels; x2 = x1 + channels; x3 = x2 + channels;

        Fixed * l0;
        Fixed * l1;
        Fixed * l2;
        Fixed * l3;

        l0 = dst; l1 = l0 + channels; l2 = l1 + channels; l3 = l2 + channels;

        _IIR_INITIAL4( 0 )
        _IIR_INITIAL4( 1 )
        _IIR_INITIAL4( 2 )
        _IIR_INITIAL4( 3 )

        // forward pass
        for( uint32_t i = 4; i < w; i++ ) {
            x0 += channels;
            x1 += channels;
            x2 += channels;
            x3 += channels;

            _IIR_CURRENT( 0 )
            _IIR_CURRENT( 1 )
            _IIR_CURRENT( 2 )
            _IIR_CURRENT( 3 )

            l0 += channels;
            l1 += channels;
            l2 += channels;
            l3 += channels;
        }
    }


    void SIMD::IIR4BwdHorizontal4Fx( uint8_t * dst, const Fixed* fwdRes, const uint8_t * src, size_t w,
                                     const Fixed * n, const Fixed * d, const Fixed & b ) const
    {
        static const uint8_t channels = 4;
        const uint8_t * x0;
        const uint8_t * x1;
        const uint8_t * x2;
        const uint8_t * x3;

        // backward border init:
        x0 = src + channels * ( w - 1 ); // last pixel of current row
        x1 = x0 - channels;
        x2 = x1 - channels;
        x3 = x2 - channels;

        const Fixed *t0, *t1, *t2, *t3;
        t0 = fwdRes + channels * ( w - 1 );
        t1 = t0 - channels;
        t2 = t1 - channels;
        t3 = t2 - channels;

        uint8_t *y0, *y1, *y2, *y3;
        y0 = dst + channels * ( w - 1 ); // last pixel in output row
        y1 = y0 - channels;
        y2 = y1 - channels;
        y3 = y2 - channels;

        Fixed lastValues[ 5 * channels ];
        Fixed *l0, *l1, *l2, *l3, *tmpVal, *tmpPtr;
        l3 = lastValues; l2 = l3 + channels; l1 = l2 + channels; l0 = l1 + channels; tmpVal = l0 + channels;

        _IIR_INITIAL4( 0 )
        y0[ 0 ] = Math::clamp( ( l0[ 0 ] + t0[ 0 ] ).round(), 0, 255 );
        y1[ 0 ] = Math::clamp( ( l1[ 0 ] + t1[ 0 ] ).round(), 0, 255 );
        y2[ 0 ] = Math::clamp( ( l2[ 0 ] + t2[ 0 ] ).round(), 0, 255 );
        y3[ 0 ] = Math::clamp( ( l3[ 0 ] + t3[ 0 ] ).round(), 0, 255 );
        _IIR_INITIAL4( 1 )
        y0[ 1 ] = Math::clamp( ( l0[ 1 ] + t0[ 1 ] ).round(), 0, 255 );
        y1[ 1 ] = Math::clamp( ( l1[ 1 ] + t1[ 1 ] ).round(), 0, 255 );
        y2[ 1 ] = Math::clamp( ( l2[ 1 ] + t2[ 1 ] ).round(), 0, 255 );
        y3[ 1 ] = Math::clamp( ( l3[ 1 ] + t3[ 1 ] ).round(), 0, 255 );
        _IIR_INITIAL4( 2 )
        y0[ 2 ] = Math::clamp( ( l0[ 2 ] + t0[ 2 ] ).round(), 0, 255 );
        y1[ 2 ] = Math::clamp( ( l1[ 2 ] + t1[ 2 ] ).round(), 0, 255 );
        y2[ 2 ] = Math::clamp( ( l2[ 2 ] + t2[ 2 ] ).round(), 0, 255 );
        y3[ 2 ] = Math::clamp( ( l3[ 2 ] + t3[ 2 ] ).round(), 0, 255 );
        _IIR_INITIAL4( 3 )
        y0[ 3 ] = Math::clamp( ( l0[ 3 ] + t0[ 3 ] ).round(), 0, 255 );
        y1[ 3 ] = Math::clamp( ( l1[ 3 ] + t1[ 3 ] ).round(), 0, 255 );
        y2[ 3 ] = Math::clamp( ( l2[ 3 ] + t2[ 3 ] ).round(), 0, 255 );
        y3[ 3 ] = Math::clamp( ( l3[ 3 ] + t3[ 3 ] ).round(), 0, 255 );

        w -= 4;

        // backward pass
        while( w-- ){
            // move input pointer back
            x0 -=channels; x1-=channels; x2-=channels; x3-=channels;
            y3 -= channels; // y3 is current output pixel!
            t3 -= channels; // result from forward pass for current pixel

            _IIR_CURRENT_BWD( 0 )
            _IIR_CURRENT_BWD( 1 )
            _IIR_CURRENT_BWD( 2 )
            _IIR_CURRENT_BWD( 3 )

            // swap pointers:
            tmpPtr = tmpVal;
            tmpVal = l0; l0 = l1; l1 = l2; l2 = l3; l3 = tmpPtr;
        }

    }


    void SIMD::IIR4FwdVertical4Fx( Fixed* buffer, const uint8_t * src, size_t sstride,
                                   size_t h, const Fixed * n, const Fixed * d, const Fixed & b ) const
    {
        static const uint8_t channels = 4;

        const uint8_t * x0 = src;
        const uint8_t * x1 = x0 + sstride;
        const uint8_t * x2 = x1 + sstride;
        const uint8_t * x3 = x2 + sstride;

        Fixed * l0 = buffer;
        Fixed * l1 = l0 + channels;
        Fixed * l2 = l1 + channels;
        Fixed * l3 = l2 + channels;

        _IIR_INITIAL4( 0 )
        _IIR_INITIAL4( 1 )
        _IIR_INITIAL4( 2 )
        _IIR_INITIAL4( 3 )

        h -= 4;

        // forward pass
        while( h-- ) {
            x0 += sstride;
            x1 += sstride;
            x2 += sstride;
            x3 += sstride;

            _IIR_CURRENT( 0 )
            _IIR_CURRENT( 1 )
            _IIR_CURRENT( 2 )
            _IIR_CURRENT( 3 )

            l0 += channels;
            l1 += channels;
            l2 += channels;
            l3 += channels;
        }
    }


    void SIMD::IIR4BwdVertical4Fx( uint8_t * dst, size_t dstride, Fixed* fwdRes,
                                   size_t h, const Fixed * n, const Fixed * d, const Fixed & b ) const
    {
        static const uint8_t channels = 4;

        Fixed * t0;
        Fixed * t1;
        Fixed * t2;
        Fixed * t3;

        t0 = fwdRes + channels * ( h - 1 ); // last pixel of current row
        t1 = t0 - channels;
        t2 = t1 - channels;
        t3 = t2 - channels;

        uint8_t *y0, *y1, *y2, *y3;
        y0 = dst + dstride * ( h - 1 ); // last pixel in output col
        y1 = y0 - dstride;
        y2 = y1 - dstride;
        y3 = y2 - dstride;

        uint8_t tmpu8[ 4 * channels ];
        uint8_t *x0, *x1, *x2, *x3, *xtmp;
        x3 = tmpu8; x2 = x3 + channels; x1 = x2 + channels; x0 = x1 + channels;

        Fixed lastValues[ 5 * channels ];
        Fixed *l0, *l1, *l2, *l3, *tmpVal, *tmpPtr;
        l3 = lastValues; l2 = l3 + channels; l1 = l2 + channels; l0 = l1 + channels; tmpVal = l0 + channels;

        // backward border init:
        x0[ 0 ] = y0[ 0 ]; x1[ 0 ] = y1[ 0 ]; x2[ 0 ] = y2[ 0 ]; x3[ 0 ] = y3[ 0 ];
        _IIR_INITIAL4( 0 );
        y0[ 0 ] = Math::clamp( ( l0[ 0 ] + t0[ 0 ] ).round(), 0, 255 );
        y1[ 0 ] = Math::clamp( ( l1[ 0 ] + t1[ 0 ] ).round(), 0, 255 );
        y2[ 0 ] = Math::clamp( ( l2[ 0 ] + t2[ 0 ] ).round(), 0, 255 );
        y3[ 0 ] = Math::clamp( ( l3[ 0 ] + t3[ 0 ] ).round(), 0, 255 );

        x0[ 1 ] = y0[ 1 ]; x1[ 1 ] = y1[ 1 ]; x2[ 1 ] = y2[ 1 ]; x3[ 1 ] = y3[ 1 ];
        _IIR_INITIAL4( 1 );
        y0[ 1 ] = Math::clamp( ( l0[ 1 ] + t0[ 1 ] ).round(), 0, 255 );
        y1[ 1 ] = Math::clamp( ( l1[ 1 ] + t1[ 1 ] ).round(), 0, 255 );
        y2[ 1 ] = Math::clamp( ( l2[ 1 ] + t2[ 1 ] ).round(), 0, 255 );
        y3[ 1 ] = Math::clamp( ( l3[ 1 ] + t3[ 1 ] ).round(), 0, 255 );

        x0[ 2 ] = y0[ 2 ]; x1[ 2 ] = y1[ 2 ]; x2[ 2 ] = y2[ 2 ]; x3[ 2 ] = y3[ 2 ];
        _IIR_INITIAL4( 2 );
        y0[ 2 ] = Math::clamp( ( l0[ 2 ] + t0[ 2 ] ).round(), 0, 255 );
        y1[ 2 ] = Math::clamp( ( l1[ 2 ] + t1[ 2 ] ).round(), 0, 255 );
        y2[ 2 ] = Math::clamp( ( l2[ 2 ] + t2[ 2 ] ).round(), 0, 255 );
        y3[ 2 ] = Math::clamp( ( l3[ 2 ] + t3[ 2 ] ).round(), 0, 255 );

        x0[ 3 ] = y0[ 3 ]; x1[ 3 ] = y1[ 3 ]; x2[ 3 ] = y2[ 3 ]; x3[ 3 ] = y3[ 3 ];
        _IIR_INITIAL4( 3 );
        y0[ 3 ] = Math::clamp( ( l0[ 3 ] + t0[ 3 ] ).round(), 0, 255 );
        y1[ 3 ] = Math::clamp( ( l1[ 3 ] + t1[ 3 ] ).round(), 0, 255 );
        y2[ 3 ] = Math::clamp( ( l2[ 3 ] + t2[ 3 ] ).round(), 0, 255 );
        y3[ 3 ] = Math::clamp( ( l3[ 3 ] + t3[ 3 ] ).round(), 0, 255 );

        h -= 4;
        // backward pass
        while( h-- ){
            // move input pointer back
            t0 -= channels;
            t1 -= channels;
            t2 -= channels;
            t3 -= channels;

            y3 -= dstride; // y3 is current output pixel!

            xtmp = x0; x0 = x1; x1 = x2; x2 = x3; x3 = xtmp;
            x3[ 0 ] = y3[ 0 ]; x3[ 1 ] = y3[ 1 ]; x3[ 2 ] = y3[ 2 ]; x3[ 3 ] = y3[ 3 ];

            _IIR_CURRENT_BWD( 0 )
            _IIR_CURRENT_BWD( 1 )
            _IIR_CURRENT_BWD( 2 )
            _IIR_CURRENT_BWD( 3 )

            // swap pointers:
            tmpPtr = tmpVal;
            tmpVal = l0; l0 = l1; l1 = l2; l2 = l3; l3 = tmpPtr;
        }
    }

    size_t SIMD::hammingDistance( const uint8_t* src1, const uint8_t* src2, size_t n ) const
    {
        size_t d = 0;
        uint64_t xored;

        size_t n8 = n >> 3;
        size_t r  = n - ( n8 << 3 );

        uint64_t* s1 = ( uint64_t* )src1;
        uint64_t* s2 = ( uint64_t* )src2;

        while( n8-- ){
            xored = *s1++ ^ *s2++;

            // count the bits set in xored:
            // 64 1-bit numbers
            xored = ( ( xored & 0xAAAAAAAAAAAAAAAAll ) >> 1 ) + ( xored & 0x5555555555555555ll );
            xored = ( ( xored & 0xCCCCCCCCCCCCCCCCll ) >> 2 ) + ( xored & 0x3333333333333333ll );
            xored = ( ( xored & 0xF0F0F0F0F0F0F0F0ll ) >> 4 ) + ( xored & 0x0F0F0F0F0F0F0F0Fll );
            xored += xored >> 32;
            xored += xored >> 16;
            xored += xored >>  8;
            //  1 8-bit number
            d+= ( xored & 0xFF );
        }

        if( r ){
            uint64_t a = 0, b = 0;

            Memcpy( ( uint8_t* )( &a ), ( uint8_t* )s1, r );
            Memcpy( ( uint8_t* )( &b ), ( uint8_t* )s2, r );

            xored = ( a^b );
            xored = ( ( xored & 0xAAAAAAAAAAAAAAAAll ) >> 1 ) + ( xored & 0x5555555555555555ll );
            xored = ( ( xored & 0xCCCCCCCCCCCCCCCCll ) >> 2 ) + ( xored & 0x3333333333333333ll );
            xored = ( ( xored & 0xF0F0F0F0F0F0F0F0ll ) >> 4 ) + ( xored & 0x0F0F0F0F0F0F0F0Fll );
            xored += xored >> 32;
            xored += xored >> 16;
            xored += xored >>  8;
            //  1 8-bit number
            d+= ( xored & 0xFF );
        }

        return d;
    }

    /*
    {
        size_t d = 0;

        while( n-- ){
            d += __builtin_popcountll( *src1++ ^ *src2++ );
        }

        return d;
    }
    */

    void SIMD::prefixSum1_u8_to_f( float * dst, size_t dstStride, const uint8_t* src, size_t srcStride, size_t width, size_t height ) const
    {
        // first row
        dst[ 0 ] = src[ 0 ];
        for( size_t i = 1; i < width; i++ ){
            dst[ i ] = dst[ i - 1 ] + src[ i ];
        }
        height--;

        float * prevRow = dst;
        dst+=dstStride;
        src+=srcStride;

        float currRow;
        while( height-- ){
            currRow = 0;
            for( size_t i = 0; i < width; i++ ){
                currRow += src[ i ];
                dst[ i ] = currRow + prevRow[ i ];
            }
            prevRow = dst;
            dst += dstStride;
            src += srcStride;
        }
    }


    void SIMD::prefixSum1_f_to_f( float * dst, size_t dstStride, const float* src, size_t srcStride, size_t width, size_t height ) const
    {
        // first row
        dst[ 0 ] = src[ 0 ];
        for( size_t i = 1; i < width; i++ ){
            dst[ i ] = dst[ i - 1 ] + src[ i ];
        }
        height--;

        float * prevRow = dst;
        dst+=dstStride;
        src+=srcStride;

        float currRow;
        while( height-- ){
            currRow = 0;
            for( size_t i = 0; i < width; i++ ){
                currRow += src[ i ];
                dst[ i ] = currRow + prevRow[ i ];
            }
            prevRow = dst;
            dst += dstStride;
            src += srcStride;
        }
    }

    void SIMD::prefixSum1_xxxxu8_to_f( float * dst, size_t dstStride, const uint8_t* src, size_t srcStride, size_t width, size_t height ) const
    {
        // first row
        dst[ 0 ] = src[ 0 ];
        dst[ 1 ] = src[ 1 ];
        dst[ 2 ] = src[ 2 ];
        dst[ 3 ] = src[ 3 ];

        // first row
        for( size_t i = 4; i < ( width << 2 ); i+=4 ){
            dst[ i ]	 = dst[ i - 4 ] + src[ i ];
            dst[ i + 1 ] = dst[ i - 3 ] + src[ i + 1 ];
            dst[ i + 2 ] = dst[ i - 2 ] + src[ i + 2 ];
            dst[ i + 3 ] = dst[ i - 1 ] + src[ i + 3 ];
        }
        height--;

        float * prevRow = dst;
        dst+=dstStride;
        src+=srcStride;

        float currRow[ 4 ];
        while( height-- ){
            currRow[ 0 ] = currRow[ 1 ] = currRow[ 2 ] = currRow[ 3 ] = 0;
            for( size_t i = 0; i < ( width << 2 ); i+=4 ){
                currRow[ 0 ] += src[ i ];
                currRow[ 1 ] += src[ i + 1 ];
                currRow[ 2 ] += src[ i + 2 ];
                currRow[ 3 ] += src[ i + 3 ];

                dst[ i ]	 = currRow[ 0 ]	+ prevRow[ i ];
                dst[ i + 1 ] = currRow[ 1 ] + prevRow[ i + 1 ];
                dst[ i + 2 ] = currRow[ 2 ] + prevRow[ i + 2 ];
                dst[ i + 3 ] = currRow[ 3 ] + prevRow[ i + 3 ];
            }
            prevRow = dst;
            dst += dstStride;
            src += srcStride;
        }
    }

    void SIMD::prefixSumSqr1_u8_to_f( float * dst, size_t dStride, const uint8_t * src, size_t srcStride, size_t width, size_t height ) const
    {
        dst[ 0 ] = Math::sqr( ( float )src[ 0 ] );
        for( size_t i = 1; i < width; i++ ){
            dst[ i ] = dst[ i - 1 ] + Math::sqr( ( float )src[ i ] );
        }
        height--;

        float * prevRow = dst;

        dst += dStride;
        src  += srcStride;

        float currRow;
        while( height-- ){
            currRow = 0;
            for( size_t i = 0; i < width; i++ ){
                currRow += Math::sqr( ( float )src[ i ] );
                dst[ i ] = currRow + prevRow[ i ];
            }

            prevRow = dst;
            dst += dStride;
            src  += srcStride;
        }
    }

    void SIMD::prefixSumSqr1_f_to_f( float * dst, size_t dStride, const float* src, size_t srcStride, size_t width, size_t height ) const
    {
        dst[ 0 ] = Math::sqr( src[ 0 ] );
        for( size_t i = 1; i < width; i++ ){
            dst[ i ] = dst[ i - 1 ] + Math::sqr( src[ i ] );
        }
        height--;

        float * prevRow = dst;

        dst += dStride;
        src  += srcStride;

        float currRow;
        while( height-- ){
            currRow = 0;
            for( size_t i = 0; i < width; i++ ){
                currRow += Math::sqr( src[ i ] );
                dst[ i ] = currRow + prevRow[ i ];
            }
            prevRow = dst;
            dst += dStride;
            src  += srcStride;
        }
    }


	void SIMD::boxFilterPrefixSum1_f_to_f( float* dst, size_t dststride, const float* src, size_t srcstride, size_t width, size_t height, size_t boxwidth, size_t boxheight ) const
	{
		// FIXME
		srcstride >>= 2;
		dststride >>= 2;

		size_t x;
		size_t y;
		size_t boxwr = boxwidth >> 1;
		size_t boxhr = boxheight >> 1;
		size_t hend = height - boxhr;
		size_t wend = width - boxwr;
		const float* A = src + srcstride * boxhr + boxwr;
		const float* B = src + boxwr;
		const float* C = src;
		const float* D = src + srcstride * boxhr;
		const float scale = 1.0f / ( boxwidth * boxheight );

		for( y = 0; y <= boxhr; y++ ) {
			for( x = 0; x <= boxwr; x++ ) {
				dst[ x ] = A[ x ] / ( float )( ( boxwr + 1 + x ) * ( boxhr + 1 + y ) );
			}
			for( ; x < wend; x++ ) {
				dst[ x ] = ( A[ x ] - D[ x - ( boxwr + 1 ) ]  ) / ( float )( boxwidth * ( boxhr + 1 + y ) );
			}
			for( ; x < width; x++ ) {
				dst[ x ] = ( A[ width - 1 - boxwr ] - D[ x - ( boxwr + 1 ) ]  ) / ( float )( ( boxwr + 1 + ( width - 1 - x ) ) * ( boxhr + 1 + y ) );
			}
			A += srcstride;
			D += srcstride;
			dst += dststride;
		}

		for( ; y < hend; y++ ) {
			for( x = 0; x <= boxwr; x++ ) {
				dst[ x ] = ( A[ x ] - B[ x ] ) / ( float )( ( boxwr + 1 + x) * ( boxheight ) );
			}
			for( ; x < wend; x++ ) {
				dst[ x ] = ( A[ x ] - D[ x - ( boxwr + 1 ) ] - B[ x ] + C[ x - ( boxwr + 1 ) ]  ) * scale;
			}
			for( ; x < width; x++ ) {
				dst[ x ] = ( A[ width - 1 - boxwr ] - D[ x - ( boxwr + 1 )] - B[ width - 1 - boxwr ] + C[ x - ( boxwr + 1) ]  ) / ( float ) ( ( boxwr + 1 + ( width - 1 - x ) ) * boxheight );
			}

			A += srcstride;
			B += srcstride;
			C += srcstride;
			D += srcstride;
			dst += dststride;
		}

		A -= srcstride;
		D -= srcstride;

		for( ; y < height; y++ ) {
			for( x = 0; x <= boxwr; x++ ) {
				dst[ x ] = ( A[ x ] - B[ x ] ) / ( float )( ( boxwr + 1 + x) * ( boxhr + 1 + ( height - 1 - y ) ) );
			}
			for( ; x < wend; x++ ) {
				dst[ x ] = ( A[ x ] - D[ x - ( boxwr + 1 ) ] - B[ x ] + C[ x - ( boxwr + 1 ) ]  ) / ( float ) ( boxwidth * ( boxhr + 1 + ( height - 1 - y ) ) );
			}
			for( ; x < width; x++ ) {
				dst[ x ] = ( A[ width - 1 - boxwr ] - D[ x - ( boxwr + 1 )] - B[ width - 1 - boxwr ] + C[ x - ( boxwr + 1) ]  ) / ( float ) ( ( boxwr + 1 + ( width - 1 - x ) ) * ( boxhr + 1 + ( height - 1 - y ) ) );
			}


			B += srcstride;
			C += srcstride;
			dst += dststride;
		}

	}

	void SIMD::boxFilterPrefixSum1_f_to_u8( uint8_t* dst, size_t dststride, const float* src, size_t srcstride, size_t width, size_t height, size_t boxwidth, size_t boxheight ) const
	{
		// FIXME
		srcstride >>= 2;

		size_t x;
		size_t y;
		size_t boxwr = boxwidth >> 1;
		size_t boxhr = boxheight >> 1;
		size_t hend = height - boxhr;
		size_t wend = width - boxwr;
		const float* A = src + srcstride * boxhr + boxwr;
		const float* B = src + boxwr;
		const float* C = src;
		const float* D = src + srcstride * boxhr;
		const float scale = 1.0f / ( boxwidth * boxheight );

		for( y = 0; y <= boxhr; y++ ) {
			for( x = 0; x <= boxwr; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp( A[ x ] / ( float )( ( boxwr + 1 + x ) * ( boxhr + 1 + y ) ), 0.0f, 255.0f );
			}
			for( ; x < wend; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp(( A[ x ] - D[ x - ( boxwr + 1 ) ]  ) / ( float )( boxwidth * ( boxhr + 1 + y ) ), 0.0f, 255.0f );
			}
			for( ; x < width; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp(( A[ width - 1 - boxwr ] - D[ x - ( boxwr + 1 ) ]  ) / ( float )( ( boxwr + 1 + ( width - 1 - x ) ) * ( boxhr + 1 + y ) ), 0.0f, 255.0f );
			}
			A += srcstride;
			D += srcstride;
			dst += dststride;
		}

		for( ; y < hend; y++ ) {
			for( x = 0; x <= boxwr; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp(( A[ x ] - B[ x ] ) / ( float )( ( boxwr + 1 + x) * ( boxheight ) ), 0.0f, 255.0f );
			}
			for( ; x < wend; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp(( A[ x ] - D[ x - ( boxwr + 1 ) ] - B[ x ] + C[ x - ( boxwr + 1 ) ]  ) * scale, 0.0f, 255.0f );
			}
			for( ; x < width; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp(( A[ width - 1 - boxwr ] - D[ x - ( boxwr + 1 )] - B[ width - 1 - boxwr ] + C[ x - ( boxwr + 1) ]  ) / ( float ) ( ( boxwr + 1 + ( width - 1 - x ) ) * boxheight ), 0.0f, 255.0f );
			}

			A += srcstride;
			B += srcstride;
			C += srcstride;
			D += srcstride;
			dst += dststride;
		}

		A -= srcstride;
		D -= srcstride;

		for( ; y < height; y++ ) {
			for( x = 0; x <= boxwr; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp( ( A[ x ] - B[ x ] ) / ( float )( ( boxwr + 1 + x) * ( boxhr + 1 + ( height - 1 - y ) ) ), 0.0f, 255.0f );
			}
			for( ; x < wend; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp( ( A[ x ] - D[ x - ( boxwr + 1 ) ] - B[ x ] + C[ x - ( boxwr + 1 ) ]  ) / ( float ) ( boxwidth * ( boxhr + 1 + ( height - 1 - y ) ) ), 0.0f, 255.0f );
			}
			for( ; x < width; x++ ) {
				dst[ x ] = ( uint8_t ) Math::clamp( ( A[ width - 1 - boxwr ] - D[ x - ( boxwr + 1 )] - B[ width - 1 - boxwr ] + C[ x - ( boxwr + 1) ]  ) / ( float ) ( ( boxwr + 1 + ( width - 1 - x ) ) * ( boxhr + 1 + ( height - 1 - y ) ) ), 0.0f, 255.0f );
			}


			B += srcstride;
			C += srcstride;
			dst += dststride;
		}

	}


	void SIMD::adaptiveThreshold1_f_to_u8( uint8_t* dst, const float* src, const float* srcmean, size_t n, float t ) const
	{
		while ( n-- ) {
			*dst++ = ( *src++ - *srcmean++ ) > t ? 0xff : 0x0;
		}
	}

	void SIMD::adaptiveThreshold1_f_to_f( float* dst, const float* src, const float* srcmean, size_t n, float t ) const
	{
		while ( n-- ) {
			*dst++ = ( *src++ - *srcmean++ ) > t ? 1.0f : 0.0f;
		}
	}

	void SIMD::threshold1_f_to_u8( uint8_t* dst, const float* src, size_t n, float t ) const
	{
		while ( n-- ) {
			*dst++ = ( *src++ ) > t ? 0xff : 0x0;
		}
	}

	void SIMD::threshold1_f_to_f( float* dst, const float* src, size_t n, float t ) const
	{
		while ( n-- ) {
			*dst++ = ( *src++ ) > t ? 1.0f : 0.0f;
		}
	}


	void SIMD::threshold1_u8_to_u8( uint8_t* dst, const uint8_t* src, size_t n, uint8_t t ) const
	{
		while( n-- ) {
			*dst++ = ( *src++ ) > t ? 0xff : 0x0;
		}
	}

	void SIMD::threshold1_u8_to_f( float* dst, const uint8_t* src, size_t n, uint8_t t ) const
	{
		while( n-- ) {
			*dst++ = ( *src++ ) > t ? 1.0f : 0;
		}
	}

    void SIMD::sumPoints( Vector2f& dst, const Vector2f* src, size_t n ) const
    {
        dst.setZero();
        while( n-- )
            dst += *src++;
    }

    void SIMD::sumPoints( Vector3f& dst, const Vector3f* src, size_t n ) const
    {
        dst.setZero();
        while( n-- )
            dst += *src++;
    }

    void SIMD::scalePoints( Vector2f* dst, const Vector2f* src, const Vector2f& scale, size_t n ) const
    {
        while( n-- )
            *dst++ = ( *src++ ).cmul( scale );
    }

    void SIMD::scalePoints( Vector3f* dst, const Vector3f* src, const Vector3f& scale, size_t n ) const
    {
        while( n-- )
            *dst++ = ( *src++ ).cmul( scale );
    }

    void SIMD::scalePoints( Vector4f* dst, const Vector4f* src, const Vector4f& scale, size_t n ) const
    {
        while( n-- )
            *dst++ = ( *src++ ).cmul( scale );
    }


    void SIMD::translatePoints( Vector2f* dst, const Vector2f* src, const Vector2f& translation, size_t n ) const
    {
        while( n-- )
            *dst++ = *src++ + translation;
    }

    void SIMD::translatePoints( Vector3f* dst, const Vector3f* src, const Vector3f& translation, size_t n ) const
    {
        while( n-- )
            *dst++ = *src++ + translation;
    }

    void SIMD::translatePoints( Vector4f* dst, const Vector4f* src, const Vector4f& translation, size_t n ) const
    {
        AddValue4f( ( float* ) dst, ( const float* ) src, ( const float (&)[ 4 ] ) translation, n * 4 );
    }


    void SIMD::transformPoints( Vector2f* dst, const Matrix2f& mat, const Vector2f* src, size_t n ) const
    {
        while( n-- )
            *dst++ = mat * *src++;
    }

    void SIMD::transformPoints( Vector2f* dst, const Matrix3f& _mat, const Vector2f* src, size_t n ) const
    {
        Matrix2f mat = _mat.toMatrix2();
        Vector2f t( _mat[ 0 ][ 2 ], _mat[ 1 ][ 2 ] );

        while( n-- )
            *dst++ = mat * *src++ + t;
    }

    void SIMD::transformPoints( Vector3f* dst, const Matrix3f& mat, const Vector3f* src, size_t n ) const
    {
        while( n-- )
            *dst++ = mat * *src++;
    }

    void SIMD::transformPoints( Vector3f* dst, const Matrix4f& _mat, const Vector3f* src, size_t n ) const
    {
        Matrix3f mat = _mat.toMatrix3();
        Vector3f t( _mat[ 0 ][ 3 ], _mat[ 1 ][ 3 ], _mat[ 1 ][ 3 ] );

        while( n-- )
            *dst++ = mat * *src++ + t;
    }

    void SIMD::transformPoints( Vector4f* dst, const Matrix4f& mat, const Vector4f* src, size_t n ) const
    {
        while( n-- )
            *dst++ = mat * *src++;
    }

    void SIMD::transformPointsHomogenize( Vector2f* dst, const Matrix3f& mat, const Vector2f* src, size_t n ) const
    {
        while( n-- )
            *dst++ = mat * *src++;
    }

    void SIMD::transformPointsHomogenize( Vector3f* dst, const Matrix4f& mat, const Vector3f* src, size_t n ) const
    {
        while( n-- )
            *dst++ = mat * *src++;
    }

    void SIMD::transformPoints( Vector3d* dst, const Matrix4d& mat, const Vector3d* src, size_t n ) const
    {
        while( n-- )
            *dst++ = mat * *src++;
    }

    void SIMD::projectPoints( Vector2f* dst, const Matrix4f& mat, const Vector3f* src, size_t n ) const
    {
        Vector3f pp;
        while( n-- ){
            pp = mat * *src++;
            dst->x = pp.x / pp.z;
            dst->y = pp.y / pp.z;
            dst++;
        }
    }

    void SIMD::projectPoints( Vector2d* dst, const Matrix4d& mat, const Vector3d* src, size_t n ) const
    {
        Vector3d pp;
        while( n-- ){
            pp = mat * *src++;
            dst->x = pp.x / pp.z;
            dst->y = pp.y / pp.z;
            dst++;
        }
    }

    void SIMD::cleanup()
    {
        if( _simd )
            delete _simd;
    }
}
